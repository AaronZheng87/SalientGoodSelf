---
title: "Analyizing the Behavioral Data of Experimental 4"
author: "Chuanpeng Hu"
date: "2016.09.10"
output: word_document
---

<style type="text/css">

body{ /* Normal  */
   font-family: Times     
   font-size: 12px;
}
td {  /* Table  */
   font-size: 8px;
}
h1 { /* Header 1 */
 font-size: 28px;
}
h2 { /* Header 2 */
 font-size: 22px;
}
h3 { /* Header 3 */
 font-size: 18px;
 color: DarkBlue;
}
code.r{ /* Code block */
  font-size: 10px;
}
pre { /* Code block */
  font-size: 10px
}
</style>


This script is aimed at making the analysis of experiments reproducible.

```{r Initializing, include=FALSE}
Sys.setlocale("LC_ALL", "English")  # set local encoding to English
Sys.setenv(LANG = "en") # set the feedback language to English
options(scipen = 999)   # force R to output in decimal instead of scientifc notion
options(digits=5)       # limit the number of reporting
rm(list = setdiff(ls(), lsf.str()))  # remove all data but keep functions

pkgTest <- function(x)
 {
   if (!require(x,character.only = TRUE))
  {
    install.packages(x,dep = TRUE)
   if(!require(x,character.only = TRUE)) stop("Package not found")
  }
}

pkgNeeded <- (c("ez","plyr","ggplot2", "reshape2", "MBESS", "bootES"))

lapply(pkgNeeded,pkgTest)

## using APA style plot ####
# Save some time and stor APA format-related code in an object so you can easily
# use it in multiple plots
windowsFonts(Times=windowsFont("TT Times New Roman")) # explicit mapping to "times"
apatheme=theme_bw()+
        theme(panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.background = element_blank(),
              panel.border = element_blank(),
              text=element_text(family='Times'),
              legend.title=element_blank(),
              legend.position='top',
              axis.line.x = element_line(color='black'),
              axis.line.y = element_line(color='black'))

# define the d prime function
dprime <- function(hit,fa) {
        qnorm(hit) - qnorm(fa)
}

## below is the code from blog, and adapted from A C Del Re from email
d.sgpp <- function(m.1,m.2,sd.1,sd.2,n,r=.5)
{
  # m.1 = mean at time 1
  # m.2 = mean at time 2
  # sd.1 = standard dev. at time 1
  # sd.2 = standard dev. at time 2
  # n = sample size
  # r = correlation between time 1 and 2
  s.within <- (sqrt((sd.1^2 + sd.2^2)-2*r*sd.1*sd.2))/(sqrt(2*(1-r))) 
  d <- ((m.1 - m.2)/s.within)
  var.d <- 2*(1-r) * (1/n + d^2/(2*n))
  out <- cbind(d, var.d)
  return(out)
}


## code for calculate the summary with sE, adopted from cook book for R
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
        library(plyr)
        
        # New version of length which can handle NA's : if na.rm == T, don't count the
        length2 <- function(x, na.rm=FALSE){
                if(na.rm) sum(!is.na(x))
                else      length(x)
        }
        
        # this does the summary. For each group's data frame, return a vector with
        # N, mean, and sd
        datac <- ddply(data,groupvars, .drop=.drop,
                       .fun = function(xx,col){
                        c(N    = length2(xx[[col]],na.rm=na.rm),
                          mean = mean(xx[[col]],na.rm=na.rm),
                          sd   = sd  (xx[[col]],na.rm=na.rm)
                           )
                       },
                       measurevar
                       )
        # Rename the "mean" column
        
        datac <- rename(datac,c("mean" = measurevar))
        
        datac$se <- datac$sd /sqrt(datac$N)   # calculate standard error of the mean
        
        # Confidence interval mltiplier for standard error
        # calculate t-statistic for confidence interval:
        # e.g., if conf.interval is .95, use .975 (above/below), and use df4 = N-1
        ciMult <- qt(conf.interval/2 + .5, datac$N-1)
        datac$ci <- datac$se * ciMult
        
        return (datac)
}

## code for calculate the summary with sE for within subject data, adopted from cook book for R
summarySEwithin <- function(data=NULL, measurevar, betweenvars=NULL, withinvars=NULL,idvar=NULL, na.rm=FALSE, conf.interval=.95, .drop=TRUE) {
        
        # Ensure that the betweenvars and withinvars are factors
        factorvars <- vapply(data[, c(betweenvars, withinvars), drop=FALSE],
                             FUN=is.factor, FUN.VALUE=logical(1))
        
        if (!all(factorvars)) {
                nonfactorvars <- names(factorvars)[!factorvars]
                message("Automatically converting the following non-factors to factors: ",
                        paste(nonfactorvars, collapse = ", "))
                data[nonfactorvars] <- lapply(data[nonfactorvars], factor)
        }
        
        # Get the means from the un-normed data
        datac <- summarySE(data, measurevar, groupvars=c(betweenvars, withinvars),
                           na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
        
        # Drop all the unused columns (these will be calculated with normed data)
        datac$sd <- NULL
        datac$se <- NULL
        datac$ci <- NULL
        
        # Norm each subject's data
        ndata <- normDataWithin(data, idvar, measurevar, betweenvars, na.rm, .drop=.drop)
        
        # This is the name of the new column
        measurevar_n <- paste(measurevar, "_norm", sep="")
        
        # Collapse the normed data - now we can treat between and within vars the same
        ndatac <- summarySE(ndata, measurevar_n, groupvars=c(betweenvars, withinvars),
                            na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
        
        # Apply correction from Morey (2008) to the standard error and confidence interval
        #  Get the product of the number of conditions of within-S variables
        nWithinGroups    <- prod(vapply(ndatac[,withinvars, drop=FALSE], FUN=nlevels,
                                        FUN.VALUE=numeric(1)))
        correctionFactor <- sqrt( nWithinGroups / (nWithinGroups-1) )
        
        # Apply the correction factor
        ndatac$sd <- ndatac$sd * correctionFactor
        ndatac$se <- ndatac$se * correctionFactor
        ndatac$ci <- ndatac$ci * correctionFactor
        
        # Combine the un-normed means with the normed results
        merge(datac, ndatac)
}

### code for normalizing the SE
normDataWithin <- function(data=NULL, idvar, measurevar, betweenvars=NULL,
                           na.rm=FALSE, .drop=TRUE) {
        library(plyr)
        
        # Measure var on left, idvar + between vars on right of formula.
        data.subjMean <- ddply(data, c(idvar, betweenvars), .drop=.drop,
                               .fun = function(xx, col, na.rm) {
                                       c(subjMean = mean(xx[,col], na.rm=na.rm))
                               },
                               measurevar,
                               na.rm
        )
        
        # Put the subject means with original data
        data <- merge(data, data.subjMean)
        
        # Get the normalized data in a new column
        measureNormedVar <- paste(measurevar, "_norm", sep="")
        data[,measureNormedVar] <- data[,measurevar] - data[,"subjMean"] +
                mean(data[,measurevar], na.rm=na.rm)
        
        # Remove this subject mean column
        data$subjMean <- NULL
        
        return(data)
}

#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
        library(grid)
        
        # Make a list from the ... arguments and plotlist
        plots <- c(list(...), plotlist)
        
        numPlots = length(plots)
        
        # If layout is NULL, then use 'cols' to determine layout
        if (is.null(layout)) {
                # Make the panel
                # ncol: Number of columns of plots
                # nrow: Number of rows needed, calculated from # of cols
                layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                                 ncol = cols, nrow = ceiling(numPlots/cols))
        }
        
        if (numPlots==1) {
                print(plots[[1]])
                
        } else {
                # Set up the page
                grid.newpage()
                pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
                
                # Make each plot, in the correct location
                for (i in 1:numPlots) {
                        # Get the i,j matrix positions of the regions that contain this subplot
                        matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
                        
                        print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                                        layout.pos.col = matchidx$col))
                }
        }
}

```

# experiment 4

```{r loadingData_e4,echo=FALSE,results='hide'}
df4 <- read.csv("rawdata_exp_behav_moral_asso_4.csv",header = TRUE, sep = ",",stringsAsFactors=FALSE,na.strings=c("","NA"))

# rename colnames
colnames(df4)[colnames(df4)=="Target.ACC"] <- "ACC"
colnames(df4)[colnames(df4)=="Target.RT"] <- "RT"
colnames(df4)[colnames(df4)=="YesNoResp"] <- "Matchness"
colnames(df4)[colnames(df4)=="self"] <- "Identity"
colnames(df4)[colnames(df4)=="morality"] <- "Morality"

# renames independent variables
df4$Morality[df4$Morality == "Good"] <- "moral"
df4$Morality[df4$Morality == "Normal"] <- "average"
df4$Morality[df4$Morality == "Bad"] <- "immoral"
df4$Morality <- factor(df4$Morality, levels=c("moral", "average","immoral")) # make the variables in a specified order
df4$Identity <- factor(df4$Identity, levels=c("self", "other"))
df4$Matchness[df4$Matchness == "Yes"] <- "match"
df4$Matchness[df4$Matchness == "No"] <- "nonmatch"
df4$Matchness <- factor(df4$Matchness, levels=c("match", "nonmatch"))

#df4$Morality[df4$Shape == 'Goodself'] <- "moral"
#df4$Identity[df4$Shape == 'Goodself'] <- "self"
#df4$Morality[df4$Shape == 'Badself'] <- "immoral"
#df4$Identity[df4$Shape == 'Badself'] <- "self"
#df4$Morality[df4$Shape == 'Normalself'] <- "average"
#df4$Identity[df4$Shape == 'Normalself'] <- "self"
#df4$Morality[df4$Shape == 'Goodother'] <- "moral"
#df4$Identity[df4$Shape == 'Goodother'] <- "other"
#df4$Morality[df4$Shape == 'Badother'] <- "immoral"
#df4$Identity[df4$Shape == 'Badother'] <- "other"
#df4$Morality[df4$Shape == 'Normalother'] <- "average"
#df4$Identity[df4$Shape == 'Normalother'] <- "other"
#df4 <- df4[,-which(names(df4) %in% "Shape")]
```


```{r clean the data_e4,echo=FALSE,results='hide',warning=FALSE, message=FALSE}
df4.P <- df4[is.na(df4$BlockList.Sample),]            # data from practice
df4.T <- df4[!(is.na(df4$BlockList.Sample)),]   # data from test

# number of participant who didn't finished the experiment
#nQuit <- length(unique(df4.P$Subject)) - length(unique(df4.T$Subject))

# trials that should be excluded from analysis because of less than 200 ms
# note that this should be reconsidered when doinng DDM analysis
# and also the trials without response
excld.trials <- df4.T[df4.T$RT <= 200,]
ratio.excld.trials <- nrow(excld.trials)/nrow(df4.T) # ratio of excluded trials in all triasl.
# caculate the overall accuracy for each subject
df4.acc.g <-  ddply(df4.T,.(Subject), summarise,
                      N = length(ACC),
                      countN = sum(ACC),
                      ACC = sum(ACC)/length(ACC))
excld.sub <- df4.acc.g$Subject[df4.acc.g$ACC < 0.6]
df4.valid <- df4.T[!(df4.T$Subject %in% excld.sub),] # exclude the invalid subjects
length(unique(df4.valid$Subject)) + length(excld.sub) == length(unique(df4$Subject))
# excld.trials3 <- excld.trials[!(excld.trials$Subject %in% excld.sub),]
excld.trials2 <- df4.valid[df4.valid$RT <= 200,]
df4.V <- df4.valid[!(df4.valid$RT <= 200),]  

## Basic information of the data ####
df4.T.basic <- df4[!duplicated(df4$Subject), 1:4]
num.subj <- nrow(df4.T.basic)
numT.female <- sum(df4.T.basic$Sex == 'female');
numT.male <- sum(df4.T.basic$Sex == 'male');
ageT.mean <- round(mean(df4.T.basic$Age),2);
ageT.std <- round(sd(df4.T.basic$Age),2);
num.excld.sub <- length(unique(excld.sub))
df4.V.basic <- df4.V[!duplicated(df4.V$Subject), 1:4]
numV.female <- sum(df4.V.basic$Sex == 'female');
numV.male <- sum(df4.V.basic$Sex == 'male');
ageV.mean <- round(mean(df4.V.basic$Age),2);
ageV.std <- round(sd(df4.V.basic$Age),2);
ratio.excld.trials2 <- nrow(excld.trials2)/nrow(df4.valid)
```

## Participants
`r num.subj` college students (`r numT.female` female, age: `r ageT.mean` $\pm$ `r ageT.std`) participated in experiment 4. All partcipants were right handed, and all had normal or corrected-to-normal vision. Informed consent was obtained from all partcipants prior to the experiment according to procedure approved by a local ethics committee. `r num.excld.sub` of the participants data were excluded from the analysis because of less than 60% overall accuracy, leaving `r num.subj - num.excld.sub` participants (`r numV.female` female, age: `r ageV.mean` $\pm$ `r ageV.std` years).

##Results
###Analaysis of d prime
```{r analyzing for d prime_e4, echo=FALSE, results='hide',warning=FALSE, message=FALSE}

df4.V$sdt <- NA
for (i in 1:nrow(df4.V)){
        if (df4.V$Target.RESP[i] == df4.V$Target.CRESP[i] & df4.V$Matchness[i] == "match"){
                df4.V$sdt[i] <- "hit"
        } else if (df4.V$Target.RESP[i] == df4.V$Target.CRESP[i] & df4.V$Matchness[i] == "nonmatch"){
                df4.V$sdt[i] <- "CR"
        } else if (df4.V$Target.RESP[i] != df4.V$Target.CRESP[i] & df4.V$Matchness[i] == "match"){
                df4.V$sdt[i] <- "miss"
        } else if (df4.V$Target.RESP[i] != df4.V$Target.CRESP[i] & df4.V$Matchness[i] == "nonmatch"){
                df4.V$sdt[i] <- "FA"
        }
}

# calculate the number of each for each condition
df4.V.SDT <-  ddply(df4.V,.(Subject,Morality, Identity,sdt), summarise, N = length(sdt))


# long format to wide
df4.V.SDT_w <- dcast(df4.V.SDT, Subject + Morality + Identity ~ sdt,value.var = "N")
df4.V.SDT_w$miss[is.na(df4.V.SDT_w$miss)] <- 0
df4.V.SDT_w$FA[is.na(df4.V.SDT_w$FA)] <- 0
df4.V.SDT_w$hitR <- df4.V.SDT_w$hit/(df4.V.SDT_w$hit + df4.V.SDT_w$miss)
df4.V.SDT_w$faR <- df4.V.SDT_w$FA/(df4.V.SDT_w$FA + df4.V.SDT_w$CR)

# standardized way to deal with the extreme values
for (i in 1:nrow(df4.V.SDT_w)){
        if (df4.V.SDT_w$hitR[i] == 1){
                df4.V.SDT_w$hitR[i] <- 1 - 1/(2*(df4.V.SDT_w$hit[i] + df4.V.SDT_w$miss[i]))
        }
}

for (i in 1:nrow(df4.V.SDT_w)){
        if (df4.V.SDT_w$faR[i] == 0){
                df4.V.SDT_w$faR[i] <- 1/(2*(df4.V.SDT_w$FA[i] + df4.V.SDT_w$CR[i]))
        }
}


# calculate the d prime for each condition
df4.V.SDT_w$dprime <- mapply(dprime,df4.V.SDT_w$hitR,df4.V.SDT_w$faR)
df4.V.SDT_w.self <- df4.V.SDT_w[df4.V.SDT_w$Identity == 'self',]
df4.V.SDT_w.other <- df4.V.SDT_w[df4.V.SDT_w$Identity == 'other',]

# anova for d prime with 2*2 design
e4.d_anova <- ezANOVA(df4.V.SDT_w,dv = dprime, wid = Subject, within=.(Morality,Identity), type=3)
e4.d_anova.self <- ezANOVA(df4.V.SDT_w.self, dv = dprime, wid = Subject, within=.(Morality), type=3)
e4.d_anova.other <- ezANOVA(df4.V.SDT_w.other, dv = dprime, wid = Subject, within=.(Morality), type=3)
#print(d_anova1)

df4.V.SDT_ww <- dcast(df4.V.SDT_w, Subject ~ Identity + Morality ,value.var = "dprime")
df4.V.SDT_ww2 <- dcast(df4.V.SDT_w, Subject ~ Identity, mean, value.var = "dprime")
# compare the main effect of identity
e4.d.t.slf_oth <- t.test(df4.V.SDT_ww2$self,df4.V.SDT_ww2$other,paired = TRUE)
df4.V.SDT_ww2$slf_oth <- df4.V.SDT_ww2$self - df4.V.SDT_ww2$other
e4.d.t.slf_oth.CI <- bootES(df4.V.SDT_ww2$slf_oth,R = 20000, effect.type = "cohens.d")

e4.d.tvalue.slf_oth <- round(as.numeric(e4.d.t.slf_oth[[1]]),3)
e4.d.df4.slf_oth <- as.numeric(e4.d.t.slf_oth[[2]])
e4.d.pvalue.slf_oth.adj <- p.adjust(as.numeric(e4.d.t.slf_oth[[3]],"bonferroni",3))
e4.d.cohens.slf_oth <- round(e4.d.t.slf_oth.CI[[1]],4) 
e4.d.CI.L.slf_oth <- round(e4.d.t.slf_oth.CI[[12]][1],4)
e4.d.CI.H.slf_oth <- round(e4.d.t.slf_oth.CI[[12]][2],4)

# t-test
# moral self vs immoral self
e4.d.t.mrl_imm_slf <- t.test(df4.V.SDT_ww$self_moral,df4.V.SDT_ww$self_immoral,paired = TRUE)
df4.V.SDT_ww$mrl_imm_slf <- df4.V.SDT_ww$self_moral - df4.V.SDT_ww$self_immoral
e4.d.t.mrl_imm_slf.CI <- bootES(df4.V.SDT_ww$mrl_imm_slf,R = 20000, effect.type = "cohens.d")

e4.d.tvalue.mrl_imm_slf <- round(as.numeric(e4.d.t.mrl_imm_slf[[1]]),3)
e4.d.df4.mrl_imm_slf <- as.numeric(e4.d.t.mrl_imm_slf[[2]])
e4.d.pvalue.mrl_imm_slf.adj <- p.adjust(as.numeric(e4.d.t.mrl_imm_slf[[3]],"bonferroni",3))
e4.d.cohens.mrl_imm_slf <- round(e4.d.t.mrl_imm_slf.CI[[1]],4) 
e4.d.CI.L.mrl_imm_slf <- round(e4.d.t.mrl_imm_slf.CI[[12]][1],4)
e4.d.CI.H.mrl_imm_slf <- round(e4.d.t.mrl_imm_slf.CI[[12]][2],4)

# moral self vs Average self
e4.d.t.mrl_ave_slf <- t.test(df4.V.SDT_ww$self_moral,df4.V.SDT_ww$self_average,paired = TRUE)
df4.V.SDT_ww$mrl_ave_slf <- df4.V.SDT_ww$self_moral - df4.V.SDT_ww$self_average
e4.d.t.mrl_ave_slf.CI <- bootES(df4.V.SDT_ww$mrl_ave_slf,R = 20000, effect.type = "cohens.d")

e4.d.tvalue.mrl_ave_slf  <- round(as.numeric(e4.d.t.mrl_ave_slf[[1]]),3)
e4.d.df4.mrl_ave_slf  <- as.numeric(e4.d.t.mrl_ave_slf[[2]])
e4.d.pvalue.mrl_ave_slf.adj <- p.adjust(as.numeric(e4.d.t.mrl_ave_slf[[3]],"bonferroni",3))
e4.d.cohens.mrl_ave_slf <- round(e4.d.t.mrl_ave_slf.CI[[1]],4) 
e4.d.CI.L.mrl_ave_slf <- round(e4.d.t.mrl_ave_slf.CI[[12]][1],4)
e4.d.CI.H.mrl_ave_slf <- round(e4.d.t.mrl_ave_slf.CI[[12]][2],4)

# immoral self vs. Average self
e4.d.t.imm_ave_slf <- t.test(df4.V.SDT_ww$self_immoral,df4.V.SDT_ww$self_average,paired = TRUE)
df4.V.SDT_ww$imm_ave_slf <- df4.V.SDT_ww$self_immoral - df4.V.SDT_ww$self_average
e4.d.t.imm_ave_slf.CI <- bootES(df4.V.SDT_ww$imm_ave_slf,R = 20000, effect.type = "cohens.d")

e4.d.tvalue.imm_ave_slf  <- round(as.numeric(e4.d.t.imm_ave_slf[[1]]),3)
e4.d.df4.imm_ave_slf  <- as.numeric(e4.d.t.imm_ave_slf[[2]])
e4.d.pvalue.imm_ave_slf.adj <- p.adjust(as.numeric(e4.d.t.imm_ave_slf[[3]],"bonferroni",3))
e4.d.cohens.imm_ave_slf <- round(e4.d.t.imm_ave_slf.CI[[1]],4) 
e4.d.CI.L.imm_ave_slf <- round(e4.d.t.imm_ave_slf.CI[[12]][1],4)
e4.d.CI.H.imm_ave_slf <- round(e4.d.t.imm_ave_slf.CI[[12]][2],4)

# moral other vs. immoral other
e4.d.t.mrl_imm_oth <- t.test(df4.V.SDT_ww$other_moral,df4.V.SDT_ww$other_immoral,paired = TRUE)
df4.V.SDT_ww$mrl_imm_oth <- df4.V.SDT_ww$other_moral - df4.V.SDT_ww$other_immoral
e4.d.t.mrl_imm_oth.CI <- bootES(df4.V.SDT_ww$mrl_imm_oth,R = 20000, effect.type = "cohens.d")

e4.d.tvalue.mrl_imm_oth  <- round(as.numeric(e4.d.t.mrl_imm_oth[[1]]),3)
e4.d.df4.mrl_imm_oth  <- as.numeric(e4.d.t.mrl_imm_oth[[2]])
e4.d.pvalue.mrl_imm_oth.adj <- p.adjust(as.numeric(e4.d.t.mrl_imm_oth[[3]],"bonferroni",3))
e4.d.cohens.mrl_imm_oth <- round(e4.d.t.mrl_imm_oth.CI[[1]],4) 
e4.d.CI.L.mrl_imm_oth <- round(e4.d.t.mrl_imm_oth.CI[[12]][1],4)
e4.d.CI.H.mrl_imm_oth <- round(e4.d.t.mrl_imm_oth.CI[[12]][2],4)

# moral other vs. average other
e4.d.t.mrl_ave_oth <- t.test(df4.V.SDT_ww$other_moral,df4.V.SDT_ww$other_average,paired = TRUE)
df4.V.SDT_ww$mrl_ave_oth <- df4.V.SDT_ww$other_moral - df4.V.SDT_ww$other_average
e4.d.t.mrl_ave_oth.CI <- bootES(df4.V.SDT_ww$mrl_ave_oth,R = 20000, effect.type = "cohens.d")

e4.d.tvalue.mrl_ave_oth  <- round(as.numeric(e4.d.t.mrl_ave_oth[[1]]),3)
e4.d.df4.mrl_ave_oth  <- as.numeric(e4.d.t.mrl_ave_oth[[2]])
e4.d.pvalue.mrl_ave_oth.adj <- p.adjust(as.numeric(e4.d.t.mrl_ave_oth[[3]],"bonferroni",3))
e4.d.cohens.mrl_ave_oth <- round(e4.d.t.mrl_ave_oth.CI[[1]],4) 
e4.d.CI.L.mrl_ave_oth <- round(e4.d.t.mrl_ave_oth.CI[[12]][1],4)
e4.d.CI.H.mrl_ave_oth <- round(e4.d.t.mrl_ave_oth.CI[[12]][2],4)

# immoral other vs. Average other
e4.d.t.imm_ave_oth <- t.test(df4.V.SDT_ww$other_immoral,df4.V.SDT_ww$other_average,paired = TRUE)
df4.V.SDT_ww$imm_ave_oth <- df4.V.SDT_ww$other_immoral - df4.V.SDT_ww$other_average
e4.d.t.imm_ave_oth.CI <- bootES(df4.V.SDT_ww$imm_ave_oth,R = 20000, effect.type = "cohens.d")

e4.d.tvalue.imm_ave_oth  <- round(as.numeric(e4.d.t.imm_ave_oth[[1]]),3)
e4.d.df4.imm_ave_oth  <- as.numeric(e4.d.t.imm_ave_oth[[2]])
e4.d.pvalue.imm_ave_oth.adj <- p.adjust(as.numeric(e4.d.t.imm_ave_oth[[3]],"bonferroni",3))
e4.d.cohens.imm_ave_oth <- round(e4.d.t.imm_ave_oth.CI[[1]],4) 
e4.d.CI.L.imm_ave_oth <- round(e4.d.t.imm_ave_oth.CI[[12]][1],4)
e4.d.CI.H.imm_ave_oth <- round(e4.d.t.imm_ave_oth.CI[[12]][2],4)

# moral self vs moral other
e4.d.t.slf_oth_mrl <- t.test(df4.V.SDT_ww$self_moral,df4.V.SDT_ww$other_moral,paired = TRUE)
df4.V.SDT_ww$slf_oth_mrl <- df4.V.SDT_ww$self_moral - df4.V.SDT_ww$other_moral
e4.d.t.slf_oth_mrl.CI <- bootES(df4.V.SDT_ww$slf_oth_mrl,R = 20000, effect.type = "cohens.d")

e4.d.tvalue.slf_oth_mrl  <- round(as.numeric(e4.d.t.slf_oth_mrl[[1]]),3)
e4.d.df4.slf_oth_mrl  <- as.numeric(e4.d.t.slf_oth_mrl[[2]])
e4.d.pvalue.slf_oth_mrl.adj <- p.adjust(as.numeric(e4.d.t.slf_oth_mrl[[3]],"bonferroni",3))
e4.d.cohens.slf_oth_mrl <- round(e4.d.t.slf_oth_mrl.CI[[1]],4) 
e4.d.CI.L.slf_oth_mrl <- round(e4.d.t.slf_oth_mrl.CI[[12]][1],4)
e4.d.CI.H.slf_oth_mrl <- round(e4.d.t.slf_oth_mrl.CI[[12]][2],4)

# Average self vs. Average other
e4.d.t.slf_oth_ave <- t.test(df4.V.SDT_ww$self_average,df4.V.SDT_ww$other_average,paired = TRUE)
df4.V.SDT_ww$slf_oth_ave <- df4.V.SDT_ww$self_average - df4.V.SDT_ww$other_average
e4.d.t.slf_oth_ave.CI <- bootES(df4.V.SDT_ww$slf_oth_ave,R = 20000, effect.type = "cohens.d")

e4.d.tvalue.slf_oth_ave  <- round(as.numeric(e4.d.t.slf_oth_ave[[1]]),3)
e4.d.df4.slf_oth_ave  <- as.numeric(e4.d.t.slf_oth_ave[[2]])
e4.d.pvalue.slf_oth_ave.adj <- p.adjust(as.numeric(e4.d.t.slf_oth_ave[[3]],"bonferroni",3))
e4.d.cohens.slf_oth_ave <- round(e4.d.t.slf_oth_ave.CI[[1]],4) 
e4.d.CI.L.slf_oth_ave <- round(e4.d.t.slf_oth_ave.CI[[12]][1],4)
e4.d.CI.H.slf_oth_ave <- round(e4.d.t.slf_oth_ave.CI[[12]][2],4)

# immoral self vs. immoral other
e4.d.t.slf_oth_imm <- t.test(df4.V.SDT_ww$self_immoral,df4.V.SDT_ww$other_immoral,paired = TRUE)
df4.V.SDT_ww$slf_oth_imm <- df4.V.SDT_ww$self_immoral - df4.V.SDT_ww$other_immoral
e4.d.t.slf_oth_imm.CI <- bootES(df4.V.SDT_ww$slf_oth_imm,R = 20000, effect.type = "cohens.d")

e4.d.tvalue.slf_oth_imm  <- round(as.numeric(e4.d.t.slf_oth_imm[[1]]),3)
e4.d.df4.slf_oth_imm <- as.numeric(e4.d.t.slf_oth_imm[[2]])
e4.d.pvalue.slf_oth_imm.adj <- p.adjust(as.numeric(e4.d.t.slf_oth_imm[[3]],"bonferroni",3))
e4.d.cohens.slf_oth_imm <- round(e4.d.t.slf_oth_imm.CI[[1]],4) 
e4.d.CI.L.slf_oth_imm <- round(e4.d.t.slf_oth_imm.CI[[12]][1],4)
e4.d.CI.H.slf_oth_imm <- round(e4.d.t.slf_oth_imm.CI[[12]][2],4)

## plot and save the results of d'
df4.V.SDT.sum <- summarySE(df4.V.SDT_w,measurevar = 'dprime',groupvars = c('Morality','Identity'))
df4.V.SDT.sum_id <- summarySE(df4.V.SDT_w,measurevar = 'dprime',groupvars = c('Identity'))
df4.V.SDT.sum_moral <- summarySE(df4.V.SDT_w,measurevar = 'dprime',groupvars = c('Morality'))

e4.d.mean.self <- round(df4.V.SDT.sum_id$dprime[df4.V.SDT.sum_id$Identity == 'self'],3)
e4.d.sd.self <- round(df4.V.SDT.sum_id$sd[df4.V.SDT.sum_id$Identity == 'self'],3)

e4.d.mean.other <- round(df4.V.SDT.sum_id$dprime[df4.V.SDT.sum_id$Identity == 'other'],3)
e4.d.sd.other <- round(df4.V.SDT.sum_id$sd[df4.V.SDT.sum_id$Identity == 'other'],3)

e4.d.mean.moralself <- round(df4.V.SDT.sum$dprime[df4.V.SDT.sum$Morality == 'moral' & df4.V.SDT.sum$Identity == 'self'],3)
e4.d.sd.moralself <- round(df4.V.SDT.sum$sd[df4.V.SDT.sum$Morality == 'moral' & df4.V.SDT.sum$Identity == 'self'],3)
e4.d.mean.immoralself <- round(df4.V.SDT.sum$dprime[df4.V.SDT.sum$Morality == 'immoral' & df4.V.SDT.sum$Identity == 'self'],3)
e4.d.sd.immoralself <- round(df4.V.SDT.sum$sd[df4.V.SDT.sum$Morality == 'immoral' & df4.V.SDT.sum$Identity == 'self'],3)
e4.d.mean.aveself <- round(df4.V.SDT.sum$dprime[df4.V.SDT.sum$Morality == 'average' & df4.V.SDT.sum$Identity == 'self'],3)
e4.d.sd.aveself <- round(df4.V.SDT.sum$sd[df4.V.SDT.sum$Morality == 'average' & df4.V.SDT.sum$Identity == 'self'],3)

e4.d.mean.moralother <- round(df4.V.SDT.sum$dprime[df4.V.SDT.sum$Morality == 'moral' & df4.V.SDT.sum$Identity == 'other'],3)
e4.d.sd.moralother <- round(df4.V.SDT.sum$sd[df4.V.SDT.sum$Morality == 'moral' & df4.V.SDT.sum$Identity == 'other'],3)
e4.d.mean.immoralother <- round(df4.V.SDT.sum$dprime[df4.V.SDT.sum$Morality == 'immoral' & df4.V.SDT.sum$Identity == 'other'],3)
e4.d.sd.immoralother <- round(df4.V.SDT.sum$sd[df4.V.SDT.sum$Morality == 'immoral' & df4.V.SDT.sum$Identity == 'other'],3)
e4.d.mean.aveother <- round(df4.V.SDT.sum$dprime[df4.V.SDT.sum$Morality == 'average' & df4.V.SDT.sum$Identity == 'other'],3)
e4.d.sd.aveother <- round(df4.V.SDT.sum$sd[df4.V.SDT.sum$Morality == 'average' & df4.V.SDT.sum$Identity == 'other'],3)

# calculate the effect size for meta
# correlation between

e4.d.cor.mrl_imm_self <- cor(df4.V.SDT_ww$self_moral,df4.V.SDT_ww$self_immoral)
e4.d.cor.mrl_ave_self <- cor(df4.V.SDT_ww$self_moral,df4.V.SDT_ww$self_average)
e4.d.cor.imm_ave_self <- cor(df4.V.SDT_ww$self_immoral,df4.V.SDT_ww$self_average)

# effect size and variance
e4.d.es.mrl_imm_self <- d.sgpp(m.1 = e4.d.mean.moralself, m.2 = e4.d.mean.immoralself, sd.1=e4.d.sd.moralself,sd.2=e4.d.sd.immoralself, n=length(df4.V.SDT_ww$self_moral),r=e4.d.cor.mrl_imm_self)

e4.d.es.mrl_ave_self <- d.sgpp(m.1 = e4.d.mean.moralself, m.2 = e4.d.mean.aveself, sd.1=e4.d.sd.moralself,sd.2=e4.d.sd.aveself, n=length(df4.V.SDT_ww$self_moral),r=e4.d.cor.mrl_ave_self)

e4.d.es.imm_ave_self <- d.sgpp(m.1 = e4.d.mean.immoralself, m.2 = e4.d.mean.aveself, sd.1=e4.d.sd.immoralself,sd.2=e4.d.sd.aveself, n=length(df4.V.SDT_ww$self_moral),r=e4.d.cor.imm_ave_self)


e4.p_dprime1 <- ggplot(data = df4.V.SDT.sum,aes(y = dprime, x = Identity, group = Morality,shape = Morality, fill = Morality)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3, width = 0.6) +         # Thinner lines
        geom_errorbar(aes(ymin = dprime - se, ymax = dprime + se),
        #geom_errorbar(aes(ymin = 1, ymax = 4),
                      size = .3,
                      width = .2,
                      position=position_dodge(.6)) +
        labs(x = 'self-referential',y = 'd prime') +
        #ylab(" Reaction times") + 
        #ylim(1, 4) +
        ggtitle("d prime for each condition") +
        coord_cartesian(ylim=c(1,3.5))+
        scale_y_continuous(breaks = seq(1,3.5,0.5),expand = c(0, 0)) +
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter. 
        #theme_classic()
        apatheme +
        theme(text = element_text(size=35))

e4.p_dprime2 <- ggplot(data = df4.V.SDT.sum,aes(y = dprime, x = Morality, group = Identity,shape = Identity, fill = Identity)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3, width = 0.6) +         # Thinner lines
        geom_errorbar(aes(ymin = dprime - se, ymax = dprime + se),
        #geom_errorbar(aes(ymin = 1, ymax = 4),
                      size = .3,
                      width = .2,
                      position=position_dodge(.6)) +
        labs(x = 'Moral valence',y = 'd prime') +
        #ylab(" Reaction times") + 
        #ylim(1, 4) +
        ggtitle("d prime for each condition") +
        coord_cartesian(ylim=c(1,3.5))+
        scale_y_continuous(breaks = seq(1,3.5,0.5),expand = c(0, 0)) +
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter. 
        #theme_classic()
        apatheme +
        theme(text = element_text(size=35))

# ggsave('dprime_mean_plot.png', width=4, height=6, unit='in', dpi=300)  # save the plot
```
ANOVA for *d'* with moral character and self-relatedness as within-subjects factors.

The main effect of `r e4.d_anova[[1]][1,1]`, *F*(`r e4.d_anova[[1]][1,2]`, `r e4.d_anova[[1]][1,3]`) = `r round(e4.d_anova[[1]][1,4],3)`, *p* = `r round(e4.d_anova[[1]][1,5],4)`, $\eta_g^2$ = `r round(e4.d_anova[[1]][1,7],4)`. 

The main effect of `r e4.d_anova[[1]][2,1]`: *F*(`r e4.d_anova[[1]][2,2]`, `r e4.d_anova[[1]][2,3]`) = `r round(e4.d_anova[[1]][2,4],3)`, *p* = `r round(e4.d_anova[[1]][2,5],4)`, $\eta_g^2$ = `r round(e4.d_anova[[1]][2,7],4)`

The interaction between `r e4.d_anova[[1]][3,1]`: *F*(`r e4.d_anova[[1]][3,2]`, `r e4.d_anova[[1]][3,3]`) = `r round(e4.d_anova[[1]][3,4],3)`, *p* = `r round(e4.d_anova[[1]][3,5],4)`, $\eta_g^2$ = `r round(e4.d_anova[[1]][3,7],4)`.

self (`r e4.d.mean.self`  $\pm$ `r e4.d.sd.self`) vs.other (`r e4.d.mean.other`  $\pm$ `r e4.d.sd.other`): *t*(`r e4.d.df4.slf_oth`) = `r e4.d.tvalue.slf_oth`, *p* = 
`r e4.d.pvalue.slf_oth.adj`, *Cohen's* $d_z$ = `r e4.d.cohens.slf_oth`, 95% CI [`r e4.d.CI.L.slf_oth` `r e4.d.CI.H.slf_oth`]


Then we conducted sample effect analysis for self- and other- association separately for the matched trials (see figure 1).

A separate repeated ANOVA for self trials showed that the effect of  `r e4.d_anova.self[[1]][1,1]`, *F*(`r e4.d_anova.self[[1]][1,2]`, `r e4.d_anova.self[[1]][1,3]`) = `r round(e4.d_anova.self[[1]][1,4],3)`, *p* = `r round(e4.d_anova.self[[1]][1,5],4)`, $\eta_g^2$ = `r round(e4.d_anova.self[[1]][1,7],4)`. 

post-hoc comparision showed that moral self (`r e4.d.mean.moralself`  $\pm$ `r e4.d.sd.moralself`) vs immoral self (`r e4.d.mean.immoralself`  $\pm$ `r e4.d.sd.immoralself`): *t*(`r e4.d.df4.mrl_imm_slf`) = `r e4.d.tvalue.mrl_imm_slf`, *p* = 
`r e4.d.pvalue.mrl_imm_slf.adj`, *Cohen's* $d_z$ = `r e4.d.cohens.mrl_imm_slf`, 95% CI [`r e4.d.CI.L.mrl_imm_slf` `r e4.d.CI.H.mrl_imm_slf`]

Moral self (`r e4.d.mean.moralself`  $\pm$ `r e4.d.sd.moralself`) vs. Average self(`r e4.d.mean.aveself`  $\pm$ `r e4.d.sd.aveself`): *t*(`r e4.d.df4.mrl_ave_slf`) = `r e4.d.tvalue.mrl_ave_slf`, *p* = 
`r e4.d.pvalue.mrl_ave_slf.adj`, *Cohen's* $d_z$ = `r e4.d.cohens.mrl_ave_slf`, 95% CI [`r e4.d.CI.L.mrl_ave_slf` `r e4.d.CI.H.mrl_ave_slf`]

Immoral self (`r e4.d.mean.immoralself`  $\pm$ `r e4.d.sd.immoralself`) vs. Average self (`r e4.d.mean.aveself` $\pm$ `r e4.d.sd.aveself`): *t*(`r e4.d.df4.imm_ave_slf`) = `r e4.d.tvalue.imm_ave_slf`, *p* = 
`r e4.d.pvalue.imm_ave_slf.adj`, *Cohen's* $d_z$ = `r e4.d.cohens.imm_ave_slf`, 95% CI [`r e4.d.CI.L.imm_ave_slf` `r e4.d.CI.H.imm_ave_slf`]

Moral other (`r e4.d.mean.moralother`  $\pm$ `r e4.d.sd.moralother`) vs immoral other (`r e4.d.mean.immoralother`  $\pm$ `r e4.d.sd.immoralother`): *t*(`r e4.d.df4.mrl_imm_oth`) = `r e4.d.tvalue.mrl_imm_oth`, *p* = 
`r e4.d.pvalue.mrl_imm_oth.adj`, *Cohen's* $d_z$ = `r e4.d.cohens.mrl_imm_oth`, 95% CI [`r e4.d.CI.L.mrl_imm_oth` `r e4.d.CI.H.mrl_imm_oth`]

Moral other (`r e4.d.mean.moralother`  $\pm$ `r e4.d.sd.moralother`) vs. Average other (`r e4.d.mean.aveother` $\pm$ `r e4.d.sd.aveother`):  *t*(`r e4.d.df4.mrl_ave_oth`) = `r e4.d.tvalue.mrl_ave_oth`, *p* = 
`r e4.d.pvalue.mrl_ave_oth.adj`, *Cohen's* $d_z$ = `r e4.d.cohens.mrl_ave_oth`, 95% CI [`r e4.d.CI.L.mrl_ave_oth` `r e4.d.CI.H.mrl_ave_oth`]

Immoral other (`r e4.d.mean.immoralother`  $\pm$ `r e4.d.sd.immoralother`) vs. Average other(`r e4.d.mean.aveother` $\pm$ `r e4.d.sd.aveother`): *t*(`r e4.d.df4.imm_ave_oth`) = `r e4.d.tvalue.imm_ave_oth`, *p* = 
`r e4.d.pvalue.imm_ave_oth.adj`, *Cohen's* $d_z$ = `r e4.d.cohens.imm_ave_oth`, 95% CI [`r e4.d.CI.L.imm_ave_oth` `r e4.d.CI.H.imm_ave_oth`]

repeated ANOVA for other trials showed that the effect of  `r e4.d_anova.other[[1]][1,1]`, *F*(`r e4.d_anova.other[[1]][1,2]`, `r e4.d_anova.other[[1]][1,3]`) = `r round(e4.d_anova.other[[1]][1,4],3)`, *p* = `r round(e4.d_anova.other[[1]][1,5],4)`, $\eta_g^2$ = `r round(e4.d_anova.other[[1]][1,7],4)`.

To examine the effect of self-relatedness, we also conducted t-test for self-other pair for each moral condition. 
moral self (`r e4.d.mean.moralself`  $\pm$ `r e4.d.sd.moralself`) vs. moral other (`r e4.d.mean.moralother`  $\pm$ `r e4.d.sd.moralother`): *t*(`r e4.d.df4.slf_oth_mrl`) = `r e4.d.tvalue.slf_oth_mrl`, *p* = `r e4.d.pvalue.slf_oth_mrl.adj`, *Cohen's* $d_z$ = `r e4.d.cohens.slf_oth_mrl`, 95% CI [`r e4.d.CI.L.slf_oth_mrl` `r e4.d.CI.H.slf_oth_mrl`]

Average self (`r e4.d.mean.aveself`  $\pm$ `r e4.d.sd.aveself`) vs. Average other (`r e4.d.mean.aveother` $\pm$ `r e4.d.sd.aveother`): *t*(`r e4.d.df4.slf_oth_ave`) = `r e4.d.tvalue.slf_oth_ave`, *p* = `r e4.d.pvalue.slf_oth_ave.adj`, *Cohen's* $d_z$ = `r e4.d.cohens.slf_oth_ave`, 95% CI [`r e4.d.CI.L.slf_oth_ave` `r e4.d.CI.H.slf_oth_ave`]
immoral self (`r e4.d.mean.immoralself` $\pm$ `r e4.d.sd.immoralself`) vs. immoral other (`r e4.d.mean.immoralother`  $\pm$ `r e4.d.sd.immoralother`): *t*(`r e4.d.df4.slf_oth_imm`) = `r e4.d.tvalue.slf_oth_imm`, *p* = `r e4.d.pvalue.slf_oth_imm.adj`, *Cohen's* $d_z$ = `r e4.d.cohens.slf_oth_imm`, 95% CI [`r e4.d.CI.L.slf_oth_imm` `r e4.d.CI.H.slf_oth_imm`]


```{r plot1 the d prime_e4, fig.width=4, fig.height=6,echo=FALSE,warning=FALSE,message=FALSE }
ggplot(data = df4.V.SDT.sum,aes(y = dprime, x = Identity, group = Morality,shape = Morality, fill = Morality)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3, width = 0.6) +         # Thinner lines
        geom_errorbar(aes(ymin = dprime - se, ymax = dprime + se),
        #geom_errorbar(aes(ymin = 1, ymax = 4),
                      size = .3,
                      width = .2,
                      position=position_dodge(.6)) +
        labs(x = 'self-referential',y = 'd prime') +
        #ylab(" Reaction times") + 
        #ylim(1, 4) +
        ggtitle("d prime for each condition") +
        coord_cartesian(ylim=c(1,3.5))+
        scale_y_continuous(breaks = seq(1,3.5,0.5),expand = c(0, 0)) +
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter. 
        #theme_classic()
        apatheme

# ggsave('dprime_mean_plot.png', width=4, height=6, unit='in', dpi=300)  # save the plot
```

The above figure shows the d prime for each condition (way 1)

```{r plot2 the d prime_e4, fig.width=4, fig.height=6,echo=FALSE,warning=FALSE,message=FALSE }
ggplot(data = df4.V.SDT.sum,aes(y = dprime, x = Morality, group = Identity,shape = Identity, fill = Identity)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3, width = 0.6) +         # Thinner lines
        geom_errorbar(aes(ymin = dprime - se, ymax = dprime + se),
        #geom_errorbar(aes(ymin = 1, ymax = 4),
                      size = .3,
                      width = .2,
                      position=position_dodge(.6)) +
        labs(x = 'Moral valence',y = 'd prime') +
        #ylab(" Reaction times") + 
        #ylim(1, 4) +
        ggtitle("d prime for each condition") +
        coord_cartesian(ylim=c(1,3.5))+
        scale_y_continuous(breaks = seq(1,3.5,0.5),expand = c(0, 0)) +
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter. 
        #theme_classic()
        apatheme

# ggsave('dprime_mean_plot.png', width=4, height=6, unit='in', dpi=300)  # save the plot
```

The above figure shows the d prime for each condition (way 2)

###Analaysis of reaction times
```{r analyzing RT_e4,echo=FALSE,results='hide',warning=FALSE, message=FALSE}
## plot density of each subject's RT and save them individually
subNo <- unique(df4.V$Subject)
## doing the analysis for RT ####
df4.V.RT <- df4.V[df4.V$ACC ==1,]  # exclued rt data less than 200 ms, and inaccurate data
df4.V.RT.subj <- summarySEwithin(df4.V.RT,measurevar = 'RT', withinvar = c('Subject','Matchness','Morality','Identity'),idvar = 'Subject', na.rm = TRUE)
df4.V.RT.grand <- summarySE(df4.V.RT.subj,measurevar = 'RT', groupvar = c('Matchness','Morality','Identity'),na.rm = TRUE)
df4.V.RT_match <- df4.V.RT[df4.V.RT$Matchness == "match",]
df4.V.RT_nonmatch <- df4.V.RT[df4.V.RT$Matchness == "nonmatch",]
df4.V.RT_match.self <- df4.V.RT_match[df4.V.RT_match$Identity == 'self',]
df4.V.RT_match.other <- df4.V.RT_match[df4.V.RT_match$Identity == 'other',]

e4.rt_anova.match <- ezANOVA(df4.V.RT_match,dv = RT, wid = Subject, within=.(Morality,Identity),within_full=.(Identity,Morality), type=3)
e4.rt_anova.nonmatch <- ezANOVA(df4.V.RT_nonmatch,dv = RT, wid = Subject, within=.(Morality,Identity),within_full=.(Identity,Morality), type=3)

e4.rt_anova.match.self <- ezANOVA(df4.V.RT_match.self,dv = RT, wid = Subject, within=.(Morality),within_full=.(Morality), type=3)
e4.rt_anova.match.other <- ezANOVA(df4.V.RT_match.other,dv = RT, wid = Subject, within=.(Morality),within_full=.(Morality), type=3)
## t-test 
df4.V.RT.subj_w <- dcast(df4.V.RT.subj, Subject ~ Matchness + Identity + Morality ,value.var = "RT") 

e4.rt.t.m.mrl_imm_slf <- t.test(df4.V.RT.subj_w$match_self_moral,df4.V.RT.subj_w$match_self_immoral,paired = TRUE)
df4.V.RT.subj_w$m.mrl_imm_slf <- df4.V.RT.subj_w$match_self_moral - df4.V.RT.subj_w$match_self_immoral
e4.rt.t.m.mrl_imm_slf.CI <- bootES(df4.V.RT.subj_w$m.mrl_imm_slf, R = 5000,effect.type = "cohens.d")

e4.rt.tvalue.mrl_imm_slf  <- round(as.numeric(e4.rt.t.m.mrl_imm_slf [[1]]),3)
e4.rt.df4.mrl_imm_slf  <- as.numeric(e4.rt.t.m.mrl_imm_slf [[2]])
e4.rt.pvalue.mrl_imm_slf.adj <- p.adjust(as.numeric(e4.rt.t.m.mrl_imm_slf [[3]],"bonferroni",3))
e4.rt.cohens.mrl_imm_slf <- round(e4.rt.t.m.mrl_imm_slf.CI[[1]],4) 
e4.rt.CI.L.mrl_imm_slf <- round(e4.rt.t.m.mrl_imm_slf.CI[[12]][1],4)
e4.rt.CI.H.mrl_imm_slf <- round(e4.rt.t.m.mrl_imm_slf.CI[[12]][2],4)


e4.rt.t.m.mrl_ave_slf <- t.test(df4.V.RT.subj_w$match_self_moral,df4.V.RT.subj_w$match_self_average,paired = TRUE)
df4.V.RT.subj_w$m.mrl_ave_slf <- df4.V.RT.subj_w$match_self_moral - df4.V.RT.subj_w$match_self_average
e4.rt.t.m.mrl_ave_slf.CI <- bootES(df4.V.RT.subj_w$m.mrl_ave_slf, R = 5000,effect.type = "cohens.d")

e4.rt.tvalue.mrl_ave_slf  <- round(as.numeric(e4.rt.t.m.mrl_ave_slf [[1]]),3)
e4.rt.df4.mrl_ave_slf  <- as.numeric(e4.rt.t.m.mrl_ave_slf[[2]])
e4.rt.pvalue.mrl_ave_slf.adj <- p.adjust(as.numeric(e4.rt.t.m.mrl_ave_slf[[3]],"bonferroni",3))
e4.rt.cohens.mrl_ave_slf <- round(e4.rt.t.m.mrl_ave_slf.CI[[1]],4) 
e4.rt.CI.L.mrl_ave_slf <- round(e4.rt.t.m.mrl_ave_slf.CI[[12]][1],4)
e4.rt.CI.H.mrl_ave_slf <- round(e4.rt.t.m.mrl_ave_slf.CI[[12]][2],4)


e4.rt.t.m.imm_ave_slf <- t.test(df4.V.RT.subj_w$match_self_immoral,df4.V.RT.subj_w$match_self_average,paired = TRUE)
df4.V.RT.subj_w$m.imm_ave_slf <- df4.V.RT.subj_w$match_self_immoral - df4.V.RT.subj_w$match_self_average
e4.rt.t.m.imm_ave_slf.CI <- bootES(df4.V.RT.subj_w$m.imm_ave_slf, R = 5000,effect.type = "cohens.d")

e4.rt.tvalue.imm_ave_slf  <- round(as.numeric(e4.rt.t.m.imm_ave_slf[[1]]),3)
e4.rt.df4.imm_ave_slf  <- as.numeric(e4.rt.t.m.imm_ave_slf[[2]])
e4.rt.pvalue.imm_ave_slf.adj <- p.adjust(as.numeric(e4.rt.t.m.imm_ave_slf[[3]],"bonferroni",3))
e4.rt.cohens.imm_ave_slf <- round(e4.rt.t.m.imm_ave_slf.CI [[1]],4) 
e4.rt.CI.L.imm_ave_slf <- round(e4.rt.t.m.imm_ave_slf.CI[[12]][1],4)
e4.rt.CI.H.imm_ave_slf <- round(e4.rt.t.m.imm_ave_slf.CI[[12]][2],4)

e4.rt.t.m.mrl_imm_oth <- t.test(df4.V.RT.subj_w$match_self_moral,df4.V.RT.subj_w$match_self_immoral,paired = TRUE)
df4.V.RT.subj_w$m.mrl_imm_oth <- df4.V.RT.subj_w$match_self_moral - df4.V.RT.subj_w$match_self_immoral
e4.rt.t.m.mrl_imm_oth.CI <- bootES(df4.V.RT.subj_w$m.mrl_imm_oth, R = 5000,effect.type = "cohens.d")

e4.rt.tvalue.mrl_imm_oth  <- round(as.numeric(e4.rt.t.m.mrl_imm_oth [[1]]),3)
e4.rt.df4.mrl_imm_oth  <- as.numeric(e4.rt.t.m.mrl_imm_oth [[2]])
e4.rt.pvalue.mrl_imm_oth.adj <- p.adjust(as.numeric(e4.rt.t.m.mrl_imm_oth [[3]],"bonferroni",3))
e4.rt.cohens.mrl_imm_oth <- round(e4.rt.t.m.mrl_imm_oth.CI [[1]],4) 
e4.rt.CI.L.mrl_imm_oth <- round(e4.rt.t.m.mrl_imm_oth.CI [[12]][1],4)
e4.rt.CI.H.mrl_imm_oth <- round(e4.rt.t.m.mrl_imm_oth.CI [[12]][2],4)


e4.rt.t.m.mrl_ave_oth <- t.test(df4.V.RT.subj_w$match_self_moral,df4.V.RT.subj_w$match_self_average,paired = TRUE)
df4.V.RT.subj_w$m.mrl_ave_oth <- df4.V.RT.subj_w$match_self_moral - df4.V.RT.subj_w$match_self_average
e4.rt.t.m.mrl_ave_oth.CI <- bootES(df4.V.RT.subj_w$m.mrl_ave_oth, R = 5000,effect.type = "cohens.d")

e4.rt.tvalue.mrl_ave_oth  <- round(as.numeric(e4.rt.t.m.mrl_ave_oth [[1]]),3)
e4.rt.df4.mrl_ave_oth  <- as.numeric(e4.rt.t.m.mrl_ave_oth[[2]])
e4.rt.pvalue.mrl_ave_oth.adj <- p.adjust(as.numeric(e4.rt.t.m.mrl_ave_oth[[3]],"bonferroni",3))
e4.rt.cohens.mrl_ave_oth <- round(e4.rt.t.m.mrl_ave_oth.CI [[1]],4) 
e4.rt.CI.L.mrl_ave_oth <- round(e4.rt.t.m.mrl_ave_oth.CI [[12]][1],4)
e4.rt.CI.H.mrl_ave_oth <- round(e4.rt.t.m.mrl_ave_oth.CI [[12]][2],4)


e4.rt.t.m.imm_ave_oth <- t.test(df4.V.RT.subj_w$match_self_immoral,df4.V.RT.subj_w$match_self_average,paired = TRUE)
df4.V.RT.subj_w$m.imm_ave_oth <- df4.V.RT.subj_w$match_self_immoral - df4.V.RT.subj_w$match_self_average
e4.rt.t.m.imm_ave_oth.CI <- bootES(df4.V.RT.subj_w$m.imm_ave_oth, R = 5000,effect.type = "cohens.d")

e4.rt.tvalue.imm_ave_oth  <- round(as.numeric(e4.rt.t.m.imm_ave_oth[[1]]),3)
e4.rt.df4.imm_ave_oth  <- as.numeric(e4.rt.t.m.imm_ave_oth[[2]])
e4.rt.pvalue.imm_ave_oth.adj <- p.adjust(as.numeric(e4.rt.t.m.imm_ave_oth[[3]],"bonferroni",3))
e4.rt.cohens.imm_ave_oth <- round(e4.rt.t.m.imm_ave_oth.CI[[1]],4) 
e4.rt.CI.L.imm_ave_oth <- round(e4.rt.t.m.imm_ave_oth.CI[[12]][1],4)
e4.rt.CI.H.imm_ave_oth <- round(e4.rt.t.m.imm_ave_oth.CI[[12]][2],4)


e4.rt.t.m.slf_oth_mrl <- t.test(df4.V.RT.subj_w$match_self_moral,df4.V.RT.subj_w$match_other_moral,paired = TRUE)
df4.V.RT.subj_w$m.slf_oth_mrl <- df4.V.RT.subj_w$match_self_moral - df4.V.RT.subj_w$match_other_moral
e4.rt.t.m.slf_oth_mrl.CI <- bootES(df4.V.RT.subj_w$m.slf_oth_mrl, R = 5000,effect.type = "cohens.d")

e4.rt.tvalue.slf_oth_mrl  <- round(as.numeric(e4.rt.t.m.slf_oth_mrl[[1]]),3)
e4.rt.df4.slf_oth_mrl  <- as.numeric(e4.rt.t.m.slf_oth_mrl[[2]])
e4.rt.pvalue.slf_oth_mrl.adj <- p.adjust(as.numeric(e4.rt.t.m.slf_oth_mrl[[3]],"bonferroni",3))
e4.rt.cohens.slf_oth_mrl <- round(e4.rt.t.m.slf_oth_mrl.CI[[1]],4) 
e4.rt.CI.L.slf_oth_mrl <- round(e4.rt.t.m.slf_oth_mrl.CI[[12]][1],4)
e4.rt.CI.H.slf_oth_mrl <- round(e4.rt.t.m.slf_oth_mrl.CI[[12]][2],4)

e4.rt.t.m.slf_oth_imm <- t.test(df4.V.RT.subj_w$match_self_immoral,df4.V.RT.subj_w$match_other_immoral,paired = TRUE)
df4.V.RT.subj_w$m.slf_oth_imm <- df4.V.RT.subj_w$match_self_immoral - df4.V.RT.subj_w$match_other_immoral
e4.rt.t.m.slf_oth_imm.CI <- bootES(df4.V.RT.subj_w$m.slf_oth_imm, R = 5000,effect.type = "cohens.d")

e4.rt.tvalue.slf_oth_imm  <- round(as.numeric(e4.rt.t.m.slf_oth_imm[[1]]),3)
e4.rt.df4.slf_oth_imm  <- as.numeric(e4.rt.t.m.slf_oth_imm[[2]])
e4.rt.pvalue.slf_oth_imm.adj <- p.adjust(as.numeric(e4.rt.t.m.slf_oth_imm[[3]],"bonferroni",3))
e4.rt.cohens.slf_oth_imm <- round(e4.rt.t.m.slf_oth_imm.CI[[1]],4) 
e4.rt.CI.L.slf_oth_imm <- round(e4.rt.t.m.slf_oth_imm.CI[[12]][1],4)
e4.rt.CI.H.slf_oth_imm <- round(e4.rt.t.m.slf_oth_imm.CI[[12]][2],4)


e4.rt.t.m.slf_oth_ave <- t.test(df4.V.RT.subj_w$match_self_average,df4.V.RT.subj_w$match_other_average,paired = TRUE)
df4.V.RT.subj_w$m.slf_oth_ave <- df4.V.RT.subj_w$match_self_average - df4.V.RT.subj_w$match_other_average
e4.rt.t.m.slf_oth_ave.CI <- bootES(df4.V.RT.subj_w$m.slf_oth_ave, R = 5000,effect.type = "cohens.d")

e4.rt.tvalue.slf_oth_ave  <- round(as.numeric(e4.rt.t.m.slf_oth_ave[[1]]),3)
e4.rt.df4.slf_oth_ave  <- as.numeric(e4.rt.t.m.slf_oth_ave[[2]])
e4.rt.pvalue.slf_oth_ave.adj <- p.adjust(as.numeric(e4.rt.t.m.slf_oth_ave[[3]],"bonferroni",3))
e4.rt.cohens.slf_oth_ave <- round(e4.rt.t.m.slf_oth_ave.CI[[1]],4) 
e4.rt.CI.L.slf_oth_ave <- round(e4.rt.t.m.slf_oth_ave.CI[[12]][1],4)
e4.rt.CI.H.slf_oth_ave <- round(e4.rt.t.m.slf_oth_ave.CI[[12]][2],4)

df4.V.RT.grand.match <- df4.V.RT.grand[df4.V.RT.grand$Matchness == "match",]

e4.rt.mean.moralself <- round(df4.V.RT.grand.match$RT[df4.V.RT.grand.match$Morality == 'moral' & df4.V.RT.grand.match$Identity == 'self'],0)
e4.rt.sd.moralself <- round(df4.V.RT.grand.match$sd[df4.V.RT.grand.match$Morality == 'moral' & df4.V.RT.grand.match$Identity == 'self'],0)
e4.rt.mean.immoralself <- round(df4.V.RT.grand.match$RT[df4.V.RT.grand.match$Morality == 'immoral' & df4.V.RT.grand.match$Identity == 'self'],0)
e4.rt.sd.immoralself <- round(df4.V.RT.grand.match$sd[df4.V.RT.grand.match$Morality == 'immoral' & df4.V.RT.grand.match$Identity == 'self'],0)
e4.rt.mean.aveself <- round(df4.V.RT.grand.match$RT[df4.V.RT.grand.match$Morality == 'average' & df4.V.RT.grand.match$Identity == 'self'],0)
e4.rt.sd.aveself <- round(df4.V.RT.grand.match$sd[df4.V.RT.grand.match$Morality == 'average' & df4.V.RT.grand.match$Identity == 'self'],0)

e4.rt.mean.moralother <- round(df4.V.RT.grand.match$RT[df4.V.RT.grand.match$Morality == 'moral' & df4.V.RT.grand.match$Identity == 'other'],0)
e4.rt.sd.moralother <- round(df4.V.RT.grand.match$sd[df4.V.RT.grand.match$Morality == 'moral' & df4.V.RT.grand.match$Identity == 'other'],0)
e4.rt.mean.immoralother <- round(df4.V.RT.grand.match$RT[df4.V.RT.grand.match$Morality == 'immoral' & df4.V.RT.grand.match$Identity == 'other'],0)
e4.rt.sd.immoralother <- round(df4.V.RT.grand.match$sd[df4.V.RT.grand.match$Morality == 'immoral' & df4.V.RT.grand.match$Identity == 'other'],0)
e4.rt.mean.aveother <- round(df4.V.RT.grand.match$RT[df4.V.RT.grand.match$Morality == 'average' & df4.V.RT.grand.match$Identity == 'other'],0)
e4.rt.sd.aveother <- round(df4.V.RT.grand.match$sd[df4.V.RT.grand.match$Morality == 'average' & df4.V.RT.grand.match$Identity == 'other'],0)

e4.p_rt1 <- ggplot(data = df4.V.RT.grand.match, aes(x=Identity,y=RT,group=Morality,shape = Morality,fill = Morality)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3, width = 0.6) +         # Thinner lines
        geom_errorbar(aes(ymin = RT-se, ymax = RT + se),
                      size = .3,
                      width = .2,
                      position=position_dodge(.6)) +
        xlab("Self-referential") +
        ylab(" Reaction times (ms)") + 
        coord_cartesian(ylim=c(500,800)) +
        scale_y_continuous(breaks=seq(500,800,50),expand = c(0, 0)) +
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter.
        #ylim(0.3, 0.8) +
        ggtitle("RT for each condition") +
        #scale_y_continuous("Reation Times (ms)") + 
        apatheme

e4.p_rt2 <- ggplot(data = df4.V.RT.grand.match, aes(x=Morality,y=RT,group=Identity,shape = Identity,fill = Identity)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3, width = 0.6) +         # Thinner lines
        geom_errorbar(aes(ymin = RT-se, ymax = RT + se),
                      size = .3,
                      width = .2,
                      position=position_dodge(.6)) +
        xlab("Moral valence") +
        ylab(" Reaction times (ms)") + 
        coord_cartesian(ylim=c(500,800))+
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter.
        #ylim(0.3, 0.8) +
        ggtitle("RT for each condition") +
        scale_y_continuous("Reation Times  (ms)",expand = c(0, 0)) + 
        apatheme
# ggsave('RT_mean_plot.png', width=4, height=6, unit='in', dpi=300)  # save the plot


tiff(filename = "Figure 3. d prime and RTs of Experiment 3.tiff", width = 8, height = 6, units = 'in', res = 300)
multiplot(e4.p_dprime1,e4.p_rt1,cols = 2)
dev.off()

tiff(filename = "Figure 3.1. d prime and RTs of Experiment 3 (way 2).tiff", width = 8, height = 6, units = 'in', res = 300)
multiplot(e4.p_dprime2,e4.p_rt2,cols = 2)
dev.off()

```

We conducted a 3 * 2 rmANOVA for RT.

**For the matched trials**.
The effect of `r e4.rt_anova.match[[1]][1,1]`: *F*(`r e4.rt_anova.match[[1]][1,2]`, `r e4.rt_anova.match[[1]][1,3]`) = `r round(e4.rt_anova.match[[1]][1,4],3)`, *p* = `r round(e4.rt_anova.match[[1]][1,5],4)`, $\eta_g^2$ = `r round(e4.rt_anova.match[[1]][1,7],4)`

The effect of `r e4.rt_anova.match[[1]][2,1]`: *F*(`r e4.rt_anova.match[[1]][2,2]`, `r e4.rt_anova.match[[1]][2,3]`) = `r round(e4.rt_anova.match[[1]][2,4],3)`, *p* = `r round(e4.rt_anova.match[[1]][2,5],4)`, $\eta_g^2$ = `r round(e4.rt_anova.match[[1]][2,7],4)`

The effect of `r e4.rt_anova.match[[1]][3,1]`: *F*(`r e4.rt_anova.match[[1]][3,2]`, `r e4.rt_anova.match[[1]][3,3]`) = `r round(e4.rt_anova.match[[1]][3,4],3)`, *p* = `r round(e4.rt_anova.match[[1]][3,5],4)`, $\eta_g^2$ = `r round(e4.rt_anova.match[[1]][3,7],4)`.

**For the nonmatched trials**, 
The effect of `r e4.rt_anova.nonmatch[[1]][1,1]`: *F*(`r e4.rt_anova.nonmatch[[1]][1,2]`, `r e4.rt_anova.nonmatch[[1]][1,3]`) = `r round(e4.rt_anova.nonmatch[[1]][1,4],3)`, *p* = `r round(e4.rt_anova.nonmatch[[1]][1,5],4)`, $\eta_g^2$ = `r round(e4.rt_anova.nonmatch[[1]][1,7],4)`

The effect of `r e4.rt_anova.nonmatch[[1]][2,1]`: *F*(`r e4.rt_anova.nonmatch[[1]][2,2]`, `r e4.rt_anova.nonmatch[[1]][2,3]`) = `r round(e4.rt_anova.nonmatch[[1]][2,4],3)`, *p* = `r round(e4.rt_anova.nonmatch[[1]][2,5],4)`, $\eta_g^2$ = `r round(e4.rt_anova.nonmatch[[1]][2,7],4)`

The effect of `r e4.rt_anova.nonmatch[[1]][3,1]`: *F*(`r e4.rt_anova.nonmatch[[1]][3,2]`, `r e4.rt_anova.nonmatch[[1]][3,3]`) = `r round(e4.rt_anova.nonmatch[[1]][3,4],3)`, *p* = `r round(e4.rt_anova.nonmatch[[1]][3,5],4)`, $\eta_g^2$ = `r round(e4.rt_anova.nonmatch[[1]][3,7],4)`.

Then we conducted sample effect analysis for self- and other- association separately for the matched trials.
A separate ANOVA for **self** trials showed that the effect of `r e4.rt_anova.match.self[[1]][1,1]`: *F*(`r e4.rt_anova.match.self[[1]][1,2]`, `r e4.rt_anova.match.self[[1]][1,3]`) = `r round(e4.rt_anova.match.self[[1]][1,4],3)`, *p* = `r round(e4.rt_anova.match.self[[1]][1,5],4)`, $\eta_g^2$ = `r round(e4.rt_anova.match.self[[1]][1,7],4)`

A separate ANOVA for **other** trials showed that the effect of `r e4.rt_anova.match.other[[1]][1,1]`: *F*(`r e4.rt_anova.match.other[[1]][1,2]`, `r e4.rt_anova.match.other[[1]][1,3]`) = `r round(e4.rt_anova.match.other[[1]][1,4],3)`, *p* = `r round(e4.rt_anova.match.other[[1]][1,5],4)`, $\eta_g^2$ = `r round(e4.rt_anova.match.other[[1]][1,7],4)`

Moral self (`r e4.rt.mean.moralself` $\pm$ `r e4.rt.sd.moralself`) vs immoral self (`r e4.rt.mean.immoralself` $\pm$ `r e4.rt.sd.immoralself`): *t*(`r e4.rt.df4.mrl_imm_slf`) = `r e4.rt.tvalue.mrl_imm_slf`, *p* = 
`r e4.rt.pvalue.mrl_imm_slf.adj`, *Cohen's* $d_z$ = `r e4.rt.cohens.mrl_imm_slf`, 95% CI [`r e4.rt.CI.L.mrl_imm_slf` `r e4.rt.CI.H.mrl_imm_slf`]

Moral self (`r e4.rt.mean.moralself` $\pm$ `r e4.rt.sd.moralself`) vs. average self (`r e4.rt.mean.aveself` $\pm$ `r e4.rt.sd.aveself`): *t*(`r e4.rt.df4.mrl_ave_slf`) = `r e4.rt.tvalue.mrl_ave_slf`, *p* = 
`r e4.rt.pvalue.mrl_ave_slf.adj`, *Cohen's* $d_z$ = `r e4.rt.cohens.mrl_ave_slf`, 95% CI [`r e4.rt.CI.L.mrl_ave_slf` `r e4.rt.CI.H.mrl_ave_slf`]

Immoral self (`r e4.rt.mean.immoralself` $\pm$ `r e4.rt.sd.immoralself`) vs. average self (`r e4.rt.mean.aveself` $\pm$ `r e4.rt.sd.aveself`): *t*(`r e4.rt.df4.imm_ave_slf`) = `r e4.rt.tvalue.imm_ave_slf`, *p* = 
`r e4.rt.pvalue.imm_ave_slf.adj`, *Cohen's* $d_z$ = `r e4.rt.cohens.imm_ave_slf`, 95% CI [`r e4.rt.CI.L.imm_ave_slf` `r e4.rt.CI.H.imm_ave_slf`]

Moral other (`r e4.rt.mean.moralother` $\pm$ `r e4.rt.sd.moralother`)  vs immoral other (`r e4.rt.mean.immoralother` $\pm$ `r e4.rt.sd.immoralother`): *t*(`r e4.rt.df4.mrl_imm_oth`) = `r e4.rt.tvalue.mrl_imm_oth`, *p* = 
`r e4.rt.pvalue.mrl_imm_oth.adj`, *Cohen's* $d_z$ = `r e4.rt.cohens.mrl_imm_oth`, 95% CI [`r e4.rt.CI.L.mrl_imm_oth` `r e4.rt.CI.H.mrl_imm_oth`]

Moral other (`r e4.rt.mean.moralother` $\pm$ `r e4.rt.sd.moralother`)  vs. average other (`r e4.rt.mean.aveother` $\pm$ `r e4.rt.sd.aveother`): *t*(`r e4.rt.df4.mrl_ave_oth`) = `r e4.rt.tvalue.mrl_ave_oth`, *p* = 
`r e4.rt.pvalue.mrl_ave_oth.adj`, *Cohen's* $d_z$ = `r e4.rt.cohens.mrl_ave_oth`, 95% CI [`r e4.rt.CI.L.mrl_ave_oth` `r e4.rt.CI.H.mrl_ave_oth`]

Immoral other (`r e4.rt.mean.immoralother` $\pm$ `r e4.rt.sd.immoralother`) vs. average other(`r e4.rt.mean.aveother` $\pm$ `r e4.rt.sd.aveother`): *t*(`r e4.rt.df4.imm_ave_oth`) = `r e4.rt.tvalue.imm_ave_oth`, *p* = 
`r e4.rt.pvalue.imm_ave_oth.adj`, *Cohen's* $d_z$ = `r e4.rt.cohens.imm_ave_oth`, 95% CI [`r e4.rt.CI.L.imm_ave_oth` `r e4.rt.CI.H.imm_ave_oth`]

To examine the effect of self-relatedness, we also conducted t-test for self-other pair for each moral condition.

moral self (`r e4.rt.mean.moralself` $\pm$ `r e4.rt.sd.moralself`) vs. moral other (`r e4.rt.mean.moralother` $\pm$ `r e4.rt.sd.moralother`) : *t*(`r e4.rt.df4.slf_oth_mrl`) = `r e4.rt.tvalue.slf_oth_mrl`, *p* = `r e4.rt.pvalue.slf_oth_mrl.adj`, *Cohen's* $d_z$ = `r e4.rt.cohens.slf_oth_mrl`, 95% CI [`r e4.rt.CI.L.slf_oth_mrl` `r e4.rt.CI.H.slf_oth_mrl`]

average self (`r e4.rt.mean.aveself` $\pm$ `r e4.rt.sd.aveself`) vs. average other (`r e4.rt.mean.aveother` $\pm$ `r e4.rt.sd.aveother`): *t*(`r e4.rt.df4.slf_oth_ave`) = `r e4.rt.tvalue.slf_oth_ave`, *p* = `r e4.rt.pvalue.slf_oth_ave.adj`, *Cohen's* $d_z$ = `r e4.rt.cohens.slf_oth_ave`, 95% CI [`r e4.rt.CI.L.slf_oth_ave` `r e4.rt.CI.H.slf_oth_ave`]

immoral self (`r e4.rt.mean.immoralself` $\pm$ `r e4.rt.sd.immoralself`) vs. immoral other (`r e4.rt.mean.immoralother` $\pm$ `r e4.rt.sd.immoralother`): *t*(`r e4.rt.df4.slf_oth_imm`) = `r e4.rt.tvalue.slf_oth_imm`, *p* = `r e4.rt.pvalue.slf_oth_imm.adj`, *Cohen's* $d_z$ = `r e4.rt.cohens.slf_oth_imm`, 95% CI [`r e4.rt.CI.L.slf_oth_imm` `r e4.rt.CI.H.slf_oth_imm`]


```{r plot2 the RT_e4, fig.width=4, fig.height=6,echo=FALSE,warning=FALSE,message=FALSE }
# change a way to plot
ggplot(data = df4.V.RT.grand.match, aes(x=Identity,y=RT,group=Morality,shape = Morality,fill = Morality)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3, width = 0.6) +         # Thinner lines
        geom_errorbar(aes(ymin = RT-se, ymax = RT + se),
                      size = .3,
                      width = .2,
                      position=position_dodge(.6)) +
        xlab("Self-referential") +
        ylab(" Reaction times (ms)") + 
        coord_cartesian(ylim=c(500,800)) +
        scale_y_continuous(breaks=seq(500,800,50),expand = c(0, 0)) +
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter.
        #ylim(0.3, 0.8) +
        ggtitle("RT for each condition") +
        #scale_y_continuous("Reation Times (ms)") + 
        apatheme
#ggsave('RT_mean_plot2.png', width=4, height=6, unit='in', dpi=300)  # save the plot

```

The above is the reaction time for each condition

```{r plot1 the RT_e4, fig.width=4, fig.height=6,echo=FALSE,warning=FALSE,message=FALSE }
# df4.V.RT.grand.match <- df4.V.RT.grand[df4.V.RT.grand$Matchness == "match",]
ggplot(data = df4.V.RT.grand.match, aes(x=Morality,y=RT,group=Identity,shape = Identity,fill = Identity)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3, width = 0.6) +         # Thinner lines
        geom_errorbar(aes(ymin = RT-se, ymax = RT + se),
                      size = .3,
                      width = .2,
                      position=position_dodge(.6)) +
        xlab("Moral valence") +
        ylab(" Reaction times (ms)") + 
        coord_cartesian(ylim=c(500,800))+
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter.
        #ylim(0.3, 0.8) +
        ggtitle("RT for each condition") +
        scale_y_continuous("Reation Times  (ms)",expand = c(0, 0)) + 
        apatheme
#ggsave('RT_mean_plot.png', width=4, height=6, unit='in', dpi=300)  # save the plot

```

The above is another way to plot.
