---
title: "Prior check and choosing prior for the second three-level model"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook for checking prior and choosing prior for the 2nd three-level model

```{r preparing, echo=FALSE, results='hide', warning=FALSE}
# set local encoding to English
if (.Platform$OS.type == 'windows') {
  Sys.setlocale(category = 'LC_ALL','English_United States.1250')
} else {
  Sys.setlocale(category = 'LC_ALL','en_US.UTF-8')
}

Sys.setenv(LANG = "en") # set the feedback language to English
options(scipen = 999)   # force R to output in decimal instead of scientifc notion
options(digits=5)       # limit the number of reporting

# rm(list = setdiff(ls(), lsf.str()))  # remove all data but keep functions

pkgNeeded <- c('tidyverse', 'here', "readr", 'matrixStats', 'ggridges',
               "afex", 'emmeans', 'lme4',
               "metafor", "Hmisc",
               "BayesFactor", 'brms', 'tidybayes', 'cmdstanr',
               "corrplot", 'patchwork',
               "psych", "lavaan", "semPlot", 'devtools')


pkgTest <- function(x){
    if (!require(x, character.only = TRUE)){
      install.packages(x, dep = TRUE)
      if(!require(x, character.only = TRUE)) stop("Package not found")
    }
  }
  
invisible(lapply(pkgNeeded, pkgTest))

rm('pkgNeeded') # remove the variable 'pkgNeeded';
rm('pkgTest')

```

```{r prepare data, echo=FALSE, results='hide', warning=FALSE, eval=FALSE}
#### Load and select data
load("AllData.RData")

# No repeating subj
df1a.v_meta <- df1a.v

# No repeating subj
df1b.v_meta <- df1b.v

# exclude participant from exp 1a
df1c.v_meta <- df1c.v %>% dplyr::filter(!Subject %in% c(1206, 1207, 1208, 1210))

# exclude participant from exp 1a
df2.v_meta <- df2.v %>% dplyr::filter(Subject > 2000)    

# exclude participants from ex1b, 1c, and 2
df3a.v_meta <- df3a.v %>% dplyr::filter(!Subject %in% c(3013, 3012, 3043, 3046)) 

# No repeating subj
df3b.v_meta <- df3b.v

# No repeating subj
df4a.v_meta <- df4a.v

# exclude participants from ex1b, 1c, and 2
df4b.v_meta <- df4b.v %>% dplyr::filter(!Subject %in% c(4210, 4202, 4201))   

# exclude participants from ex1b, 1c, and 2
df5.v_meta <- df5.v %>% dplyr::filter(!Subject %in% c(5201))   

# exclude participants from ex1b, 1c, and 2
df6a.v_meta <- df6a.v %>% dplyr::filter(!Subject %in% c(6118,6119,6122,6123,6131))   

# exclude participants from ex1b, 1c, and 2
df6b.v_meta <- df6b_d1.v %>% dplyr::filter(!Subject %in% c(6217))   

# exclude participants from ex1b, 1c, and 2
df7a.v_meta <- df7a_m.v %>% dplyr::filter(!Subject %in% c(7020))   

# No repeating subj
df7b.v_meta <- df7b_m.v

df1a.v_meta$ExpID <- 'Exp1a'
df1b.v_meta$ExpID <- 'Exp1b'
df1c.v_meta$ExpID <- 'Exp1c'
df2.v_meta$ExpID  <- 'Exp2'
df3a.v_meta$ExpID <- 'Exp3a'
df3b.v_meta$ExpID <- 'Exp3b'
df4a.v_meta$ExpID <- 'Exp4a'
df4b.v_meta$ExpID <- 'Exp4b'
df5.v_meta$ExpID  <- 'Exp5'
df6a.v_meta$ExpID <- 'Exp6a'
df6b.v_meta$ExpID <- 'Exp6b'
df7a.v_meta$ExpID <- 'Exp7a'
df7b.v_meta$ExpID <- 'Exp7b'

selected_columns <- c('ExpID', 'Site', 'Subject','Age', 'Sex', 'Matchness', 'Identity', 'Valence', 'RESP', 'ACC','RT')

df_ms <- dplyr::bind_rows(df3a.v_meta[selected_columns],
                          df3b.v_meta[selected_columns],
                          df6b.v_meta[selected_columns]) %>%
  dplyr::mutate(ExpID_new = paste(ExpID, Site, sep = "_")) %>%
  dplyr::mutate(Valence = factor(Valence, levels = c('Neutral', 'Bad', 'Good')))

df_ms_subj <- df_ms %>%
  dplyr::group_by(ExpID_new, Site) %>%
  dplyr::summarize(N = n_distinct(Subject),
                   N_trial = length(Subject),
                   Exp_conds = 6,
                   trial_per_cond = round((length(Subject)/6)/N, 0))

df_ms <- df_ms %>%
  dplyr::filter(!is.na(RESP)) %>%   # filter trials without response
  dplyr::filter(RT >= 200) %>%      # this step is important
  dplyr::mutate(ismatch = ifelse(Matchness == 'Match', 1, 0),
                saymatch = ifelse((Matchness == 'Match' & ACC == 1) | 
                                    (Matchness == 'Mismatch' & ACC == 0), 1, 0),
                Valence = factor(Valence, levels = c('Neutral', 'Bad', 'Good')),
                Identity = factor(Identity, levels = c('Self', 'Other'))) %>%
  dplyr::select(ExpID_new, Subject, Matchness, Identity,Valence, RESP, ACC, RT, ismatch, saymatch) %>%
  dplyr::mutate(ismatch_num = ifelse(Matchness == 'Match', 0.5, -0.5))

# randamly pick 15 participants from each experiment
set.seed(123)
df_ms_test <- df_ms %>%
  dplyr::distinct(ExpID_new, Subject) %>%
  dplyr::group_by(ExpID_new) %>%
  dplyr::sample_n(., 15)

df_test <- df_ms %>%
  dplyr::filter(Subject %in% df_ms_test$Subject) %>%
  #tidyr::separate(ExpID_new, c('ExpID', 'location'), "_") %>%
  dplyr::select(ExpID_new, Subject, ismatch, Identity, Valence, ACC, RT)

write.csv(df_test, 'df_test.csv', row.names = F)        
```

```{r load testing data, echo=FALSE, results='hide', warning=FALSE}
df_test <- read.csv('df_test.csv')
```

## Mode for RTs

For the reaction time, we used the log normal distribution (https://lindeloev.github.io/shiny-rt/#34_(shifted)_log-normal) to model the data. This means that we need to estimate the posterior of two parameters: $\mu$, $\sigma$. $\mu$ is the mean of the `logNormal` distribution, and $\sigma$ is the disperse of the distribution. Although the log normal distribution can be extended to shifted log normal distribution, with one more parameter: shift, which is the earliest possible response.

The reaction time of the $j$th subject on $i$th trial is a linear function of trial type: $$y_{ij} = \beta_{0j} + \beta_{1j}*IsMatch_{ij} * Valence_{ij}$$

while the log of the reaction time is log-normal distributed:
$$ log(y_{ij}) \sim N(\mu_{j}, \sigma_{j})$$ 
$y_{ij}$ is the RT of the $i$th trial of the $j$th participants.

$$\mu_{j} \sim N(\mu, \sigma)$$

$$\sigma_{j} \sim Cauchy()$$
Formula used for modeling the data as follow:

`RT_sec ~ Valence*ismatch + (Valence*ismatch | Subject), family = lognormal()`

or 

`RT_sec ~ ID*Valence*ismatch + (ID*Valence*ismatch | Subject), family = lognormal()`

we expanded the RT model three-level model in which participants and experiments are two group level variable and participants were nested in the experiments.

$$ log(y_{ijk}) \sim N(\mu_{jk}, \sigma_{jk})$$ 

$y_{ijk}$ is the RT of the $i$th trial of the $j$th participants in the $k$th experiment.

$$\mu_{jk} \sim N(\mu_{k}, \sigma_{k})$$
$$\sigma_{jk} \sim Cauchy()$$
$$\mu_{k} \sim N(\mu, \sigma)$$
$$\theta_{k} \sim Cauchy()$$

## prior check

If we use the default prior in `brms`, then the prior of the parameters are as below: 

b ---- flat
$$\beta_{k} \sim U()$$
intercept  ---- t(3, -0.3, 2.5)
$$ \alpha_{k} \sim t(3, -0.3, 2.5)$$

L ---- lkj_corr_cholesky(1)

ndt ---- Uni(0, min_Y)
$$ ndt \sim U(0, min_Y)$$

sd ---- t(3, 0, 2.5)

$$\sigma_{k} \sim t(3, 0, 2.5)$$
$$\mu_{jk} \sim N(\mu_{k}, \sigma_{k})$$
sigma ---- t(3, 0, 2.5)

We will first check whether these prior make sense.

To do that, we will use a very simple model with 


## set priors
b in first series of exp is from -0.07 ~ 0.02, using N (0, 0.1), check it hist(rnorm(1000, mean=0, sd = 0.1))
intercept in first series of exp is from -0.4, se = 0.06, using a related wide prior N(-0.4, 0.3)
sd in 1st series of exp is form 0.03 ~ 0.1


```{r testing models}
# fit a three-level hierarchical model for RT, didn't specify the prior, shifted_lognormal, effective coding
m1_test <- df_test %>%
  dplyr::mutate(RT_sec = RT/1000) %>% # log RT in seconds
  dplyr::filter(ACC == 1) %>%         # only correct trials
  brms::brm(RT_sec ~ ismatch*Identity*Valence + 
              (ismatch*Identity*Valence | ExpID_new) +   
              (ismatch*Identity*Valence | ExpID_new:Subject),
            family=shifted_lognormal(),
            data = .,
            chains = 4,
            control = list(adapt_delta = .90),
            # iter = 4000,
            # thin = 2,
            cores = parallel::detectCores(),
            threads = threading(2),
            backend = 'cmdstanr',  # with cmdstanr
            file = here::here("glmmModels/RT_ms_test_m1"))

# summary(RT_ms_m1)  # ndt = 0 there fore, we used lognormal.
# pp_check(RT_val_m1)

prior_list <- c(#set_prior('normal(0, 3)', class = 'intercept'),
  set_prior('normal(0, 0.1)', class = 'b'))
RT_ms_m2 <- df_ms %>%
  dplyr::mutate(RT_sec = RT/1000) %>% # log RT in seconds
  dplyr::filter(ACC == 1) %>%         # only correct trials
  brms::brm(RT_sec ~ ismatch*Identity*Valence + 
              (ismatch*Identity*Valence | ExpID_new) +   
              (ismatch*Identity*Valence | ExpID_new:Subject),
            family=shifted_lognormal(),
            data = .,
            prior = prior_list,
            chains = 4,
            control = list(adapt_delta = .95),
            iter = 2000,
            thin = 1,
            cores = parallel::detectCores(),
            backend = 'cmdstanr',  # with cmdstanr
            file = here::here("glmmModels/RT_ms_DummyCode_3_level_m2"))

RT_ms_m3 <- df_ms %>%
  dplyr::filter(Subject %in% df_ms_test$Subject) %>%
  # dplyr::group_by(ExpID_new, Subject, ismatch, Identity, Valence) %>%
  # dplyr::summarise(n = n())
  dplyr::mutate(RT_sec = RT/1000) %>% # log RT in seconds
  dplyr::filter(ACC == 1) %>%         # only correct trials
  brms::brm(RT_sec ~ ismatch*Identity*Valence + 
              (ismatch*Identity*Valence || ExpID_new) +    # make the model simpler stop the correlation on this level
              (ismatch*Identity*Valence | ExpID_new:Subject),
            family=shifted_lognormal(),
            data = .,
            prior = prior_list,
            chains = 4,
            control = list(adapt_delta = .95), 
            iter = 2000,
            thin = 1,
            cores = parallel::detectCores(),
            backend = 'cmdstanr',  # with cmdstanr
            file = here::here("glmmModels/RT_ms_DummyCode_3_level_m3"))

RT_ms_m4 <- df_ms %>%
  dplyr::filter(Subject %in% df_ms_test$Subject) %>%
  # dplyr::group_by(ExpID_new, Subject, ismatch, Identity, Valence) %>%
  # dplyr::summarise(n = n())
  dplyr::mutate(RT_sec = RT/1000) %>% # log RT in seconds
  dplyr::filter(ACC == 1) %>%         # only correct trials
  brms::brm(RT_sec ~ ismatch*Identity*Valence + 
              (1 | ExpID_new) +    # make the model simpler stop the correlation on this level
              (1 | ExpID_new:Subject),
            family=shifted_lognormal(),
            data = .,
            prior = prior_list,
            chains = 4,
            control = list(adapt_delta = .95), 
            iter = 6000,
            thin = 1,
            cores = parallel::detectCores(),
            backend = 'cmdstanr',  # with cmdstanr
            threads = threading(2),
            file = here::here("glmmModels/RT_ms_DummyCode_3_level_m4"))
# model with random slope for each exp
RT_ms_m5 <- df_ms %>%
  dplyr::filter(Subject %in% df_ms_test$Subject) %>%
  # dplyr::group_by(ExpID_new, Subject, ismatch, Identity, Valence) %>%
  # dplyr::summarise(n = n())
  dplyr::mutate(RT_sec = RT/1000) %>% # log RT in seconds
  dplyr::filter(ACC == 1) %>%         # only correct trials
  brms::brm(RT_sec ~ ismatch*Identity*Valence + 
              (ismatch*Identity*Valence | ExpID_new) + 
              (1 | ExpID_new:Subject),
            family=shifted_lognormal(),
            data = .,
            prior = prior_list,
            chains = 4,
            control = list(adapt_delta = .98), 
            iter = 8000,
            thin = 1,
            cores = parallel::detectCores(),
            backend = 'cmdstanr',  # with cmdstanr
            threads = threading(2),
            file = here::here("glmmModels/RT_ms_DummyCode_3_level_m5"))
summary(RT_ms_m5)
```