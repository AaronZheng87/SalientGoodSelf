---
title: "Analyizing the Behavioral Data of Experimental 5"
author: "Chuanpeng Hu"
date: "Sunday, Aug 07, 2016"
output: word_document
---

<style type="text/css">

body{ /* Normal  */
   font-family: Times     
   font-size: 12px;
}
td {  /* Table  */
   font-size: 8px;
}
h1 { /* Header 1 */
 font-size: 28px;
}
h2 { /* Header 2 */
 font-size: 22px;
}
h3 { /* Header 3 */
 font-size: 18px;
 color: DarkBlue;
}
code.r{ /* Code block */
  font-size: 10px;
}
pre { /* Code block */
  font-size: 10px
}
</style>


This script is aimed at making the analysis of experiments reproducible.

```{r Initializing, include=FALSE}
Sys.setlocale("LC_ALL", "English")  # set local encoding to English
Sys.setenv(LANG = "en") # set the feedback language to English
options(scipen = 999)   # force R to output in decimal instead of scientifc notion
options(digits=5)       # limit the number of reporting
rm(list = setdiff(ls(), lsf.str()))  # remove all data but keep functions

pkgTest <- function(x)
 {
   if (!require(x,character.only = TRUE))
  {
    install.packages(x,dep = TRUE)
   if(!require(x,character.only = TRUE)) stop("Package not found")
  }
}

pkgNeeded <- (c("ez","plyr","ggplot2", "reshape2", "MBESS", "bootES"))

lapply(pkgNeeded,pkgTest)

## code for calculate the summary with sE, adopted from cook book for R
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
        library(plyr)
        
        # New version of length which can handle NA's : if na.rm == T, don't count the
        length2 <- function(x, na.rm=FALSE){
                if(na.rm) sum(!is.na(x))
                else      length(x)
        }
        
        # this does the summary. For each group's data frame, return a vector with
        # N, mean, and sd
        datac <- ddply(data,groupvars, .drop=.drop,
                       .fun = function(xx,col){
                        c(N    = length2(xx[[col]],na.rm=na.rm),
                          mean = mean(xx[[col]],na.rm=na.rm),
                          sd   = sd  (xx[[col]],na.rm=na.rm)
                           )
                       },
                       measurevar
                       )
        # Rename the "mean" column
        
        datac <- rename(datac,c("mean" = measurevar))
        
        datac$se <- datac$sd /sqrt(datac$N)   # calculate standard error of the mean
        
        # Confidence interval mltiplier for standard error
        # calculate t-statistic for confidence interval:
        # e.g., if conf.interval is .95, use .975 (above/below), and use df = N-1
        ciMult <- qt(conf.interval/2 + .5, datac$N-1)
        datac$ci <- datac$se * ciMult
        
        return (datac)
}

## code for calculate the summary with sE for within subject data, adopted from cook book for R
summarySEwithin <- function(data=NULL, measurevar, betweenvars=NULL, withinvars=NULL,idvar=NULL, na.rm=FALSE, conf.interval=.95, .drop=TRUE) {
        
        # Ensure that the betweenvars and withinvars are factors
        factorvars <- vapply(data[, c(betweenvars, withinvars), drop=FALSE],
                             FUN=is.factor, FUN.VALUE=logical(1))
        
        if (!all(factorvars)) {
                nonfactorvars <- names(factorvars)[!factorvars]
                message("Automatically converting the following non-factors to factors: ",
                        paste(nonfactorvars, collapse = ", "))
                data[nonfactorvars] <- lapply(data[nonfactorvars], factor)
        }
        
        # Get the means from the un-normed data
        datac <- summarySE(data, measurevar, groupvars=c(betweenvars, withinvars),
                           na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
        
        # Drop all the unused columns (these will be calculated with normed data)
        datac$sd <- NULL
        datac$se <- NULL
        datac$ci <- NULL
        
        # Norm each subject's data
        ndata <- normDataWithin(data, idvar, measurevar, betweenvars, na.rm, .drop=.drop)
        
        # This is the name of the new column
        measurevar_n <- paste(measurevar, "_norm", sep="")
        
        # Collapse the normed data - now we can treat between and within vars the same
        ndatac <- summarySE(ndata, measurevar_n, groupvars=c(betweenvars, withinvars),
                            na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)
        
        # Apply correction from Morey (2008) to the standard error and confidence interval
        #  Get the product of the number of conditions of within-S variables
        nWithinGroups    <- prod(vapply(ndatac[,withinvars, drop=FALSE], FUN=nlevels,
                                        FUN.VALUE=numeric(1)))
        correctionFactor <- sqrt( nWithinGroups / (nWithinGroups-1) )
        
        # Apply the correction factor
        ndatac$sd <- ndatac$sd * correctionFactor
        ndatac$se <- ndatac$se * correctionFactor
        ndatac$ci <- ndatac$ci * correctionFactor
        
        # Combine the un-normed means with the normed results
        merge(datac, ndatac)
}

### code for normalizing the SE
normDataWithin <- function(data=NULL, idvar, measurevar, betweenvars=NULL,
                           na.rm=FALSE, .drop=TRUE) {
        library(plyr)
        
        # Measure var on left, idvar + between vars on right of formula.
        data.subjMean <- ddply(data, c(idvar, betweenvars), .drop=.drop,
                               .fun = function(xx, col, na.rm) {
                                       c(subjMean = mean(xx[,col], na.rm=na.rm))
                               },
                               measurevar,
                               na.rm
        )
        
        # Put the subject means with original data
        data <- merge(data, data.subjMean)
        
        # Get the normalized data in a new column
        measureNormedVar <- paste(measurevar, "_norm", sep="")
        data[,measureNormedVar] <- data[,measurevar] - data[,"subjMean"] +
                mean(data[,measurevar], na.rm=na.rm)
        
        # Remove this subject mean column
        data$subjMean <- NULL
        
        return(data)
}

#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
        library(grid)
        
        # Make a list from the ... arguments and plotlist
        plots <- c(list(...), plotlist)
        
        numPlots = length(plots)
        
        # If layout is NULL, then use 'cols' to determine layout
        if (is.null(layout)) {
                # Make the panel
                # ncol: Number of columns of plots
                # nrow: Number of rows needed, calculated from # of cols
                layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                                 ncol = cols, nrow = ceiling(numPlots/cols))
        }
        
        if (numPlots==1) {
                print(plots[[1]])
                
        } else {
                # Set up the page
                grid.newpage()
                pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
                
                # Make each plot, in the correct location
                for (i in 1:numPlots) {
                        # Get the i,j matrix positions of the regions that contain this subplot
                        matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
                        
                        print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                                        layout.pos.col = matchidx$col))
                }
        }
}

## using APA style plot ####
# Save some time and stor APA format-related code in an object so you can easily
# use it in multiple plots
windowsFonts(Times=windowsFont("TT Times New Roman")) # explicit mapping to "times"
apatheme=theme_bw()+
        theme(panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.background = element_blank(),
              panel.border = element_blank(),
              text=element_text(family='Times'),
              legend.title=element_blank(),
              legend.position='top',
              axis.line.x = element_line(color='black'),
              axis.line.y = element_line(color='black'))
```



```{r loadingData,echo=FALSE,results='hide'}
df <- read.csv("rawdata_exp_behav_moral_asso_5.csv",header = TRUE, sep = ",",stringsAsFactors=FALSE,na.strings=c("","NA"))

# rename colnames
colnames(df)[colnames(df)=="Target.ACC"] <- "ACC"
colnames(df)[colnames(df)=="Target.RT"] <- "RT"
colnames(df)[colnames(df)=="YesNoResp"] <- "matchness"

# renames independent variables
df$morality[df$morality == "Good"] <- "moral"
df$morality[df$morality == "Ord"] <- "ordinary"
df$morality[df$morality == "Bad"] <- "immoral"
df$morality <- factor(df$morality, levels=c("moral", "ordinary","immoral")) # make the variables in a specified order
df$Identity <- factor(df$Identity, levels=c("self", "other"))
df$matchness[df$matchness == "Yes"] <- "match"
df$matchness[df$matchness == "No"] <- "nonmatch"
df$matchness <- factor(df$matchness, levels=c("match", "nonmatch"))

```


```{r clean the data,echo=FALSE,results='hide',warning=FALSE, message=FALSE}
df.P <- df[is.na(df$BlockList.Sample),]            # data from practice
df.T <- df[complete.cases(df$BlockList.Sample),]   # data from test

# trials that should be excluded from analysis because of less than 200 ms
# note that this should be reconsidered when doinng DDM analysis
# and also the trials without response
excld.trials <- df.T[df.T$RT <= 200,]
ratio.excld.trials <- nrow(excld.trials)/nrow(df.T) # ratio of excluded trials in all triasl.
# caculate the overall accuracy for each subject
df.acc.g <-  ddply(df.T,.(Subject), summarise,
                      N = length(ACC),
                      countN = sum(ACC),
                      ACC = sum(ACC)/length(ACC))
excld.sub <- df.acc.g$Subject[df.acc.g$ACC < 0.6 | df.acc.g$N < 0.6*720]
df.valid <- df.T[!(df.T$Subject %in% excld.sub),] # exclude the invalid subjects
length(unique(df.valid$Subject)) + length(excld.sub) == length(unique(df$Subject))
# excld.trials3 <- excld.trials[!(excld.trials$Subject %in% excld.sub),]
excld.trials2 <- df.valid[df.valid$RT <= 200,]
df.V <- df.valid[!(df.valid$RT <= 200),]  

## Basic information of the data ####
df.T.basic <- df.T[!duplicated(df.T$Subject), 1:4]
num.subj <- nrow(df.T.basic)
numT.female <- sum(df.T.basic$Sex == 'female');
numT.male <- sum(df.T.basic$Sex == 'male');
ageT.mean <- round(mean(df.T.basic$Age),2);
ageT.std <- round(sd(df.T.basic$Age),2);
num.excld.sub <- length(unique(excld.sub))
df.V.basic <- df.V[!duplicated(df.V$Subject), 1:4]
numV.female <- sum(df.V.basic$Sex == 'female');
numV.male <- sum(df.V.basic$Sex == 'male');
ageV.mean <- round(mean(df.V.basic$Age),2);
ageV.std <- round(sd(df.V.basic$Age),2);
ratio.excld.trials2 <- nrow(excld.trials2)/nrow(df.valid)
```

## Participants
`r num.subj` participants were recruited from local university community (`r numT.female` female, age: `r ageT.mean` $\pm$ `r ageT.std`), All participants had normal vision or corrected-to-normal vision and right handed. `r num.excld.sub` of the participants data were excluded from the analysis because of less than 60% overall accuracy, leaving `r num.subj - num.excld.sub` participants (`r numV.female` female, age: `r ageV.mean` $\pm$ `r ageV.std` years).

##Results
###Analaysis of d prime
```{r analyzing for d prime, echo=FALSE, results='hide',warning=FALSE, message=FALSE}

df.V$sdt <- NA
for (i in 1:nrow(df.V)){
        if (df.V$Target.RESP[i] == df.V$Target.CRESP[i] & df.V$matchness[i] == "match"){
                df.V$sdt[i] <- "hit"
        } else if (df.V$Target.RESP[i] == df.V$Target.CRESP[i] & df.V$matchness[i] == "nonmatch"){
                df.V$sdt[i] <- "CR"
        } else if (df.V$Target.RESP[i] != df.V$Target.CRESP[i] & df.V$matchness[i] == "match"){
                df.V$sdt[i] <- "miss"
        } else if (df.V$Target.RESP[i] != df.V$Target.CRESP[i] & df.V$matchness[i] == "nonmatch"){
                df.V$sdt[i] <- "FA"
        }
}

# calculate the number of each for each condition
df.V.SDT <-  ddply(df.V,.(Subject,morality, Identity,sdt), summarise,
                   N = length(sdt))


# long format to wide
df.V.SDT_w <- dcast(df.V.SDT, Subject + morality + Identity ~ sdt,value.var = "N")
df.V.SDT_w$miss[is.na(df.V.SDT_w$miss)] <- 0
df.V.SDT_w$FA[is.na(df.V.SDT_w$FA)] <- 0
df.V.SDT_w$hitR <- df.V.SDT_w$hit/(df.V.SDT_w$hit + df.V.SDT_w$miss)
df.V.SDT_w$faR <- df.V.SDT_w$FA/(df.V.SDT_w$FA + df.V.SDT_w$CR)

# standardized way to deal with the extreme values
for (i in 1:nrow(df.V.SDT_w)){
        if (df.V.SDT_w$hitR[i] == 1){
                df.V.SDT_w$hitR[i] <- 1 - 1/(2*(df.V.SDT_w$hit[i] + df.V.SDT_w$miss[i]))
        }
}

for (i in 1:nrow(df.V.SDT_w)){
        if (df.V.SDT_w$faR[i] == 0){
                df.V.SDT_w$faR[i] <- 1/(2*(df.V.SDT_w$FA[i] + df.V.SDT_w$CR[i]))
        }
}

# define the d prime function
dprime <- function(hit,fa) {
        qnorm(hit) - qnorm(fa)
}

# calculate the d prime for each condition
df.V.SDT_w$dprime <- mapply(dprime,df.V.SDT_w$hitR,df.V.SDT_w$faR)

# anova for d prime with 2*2 design
d_anova1 <- ezANOVA(df.V.SDT_w,dv = dprime, wid = Subject, within=.(morality,Identity), type=3)
#print(d_anova1)

df.V.SDT_ww <- dcast(df.V.SDT_w, Subject ~ Identity + morality ,value.var = "dprime")

# t-test
# moral self vs immoral self
d.t.mrl_imm_slf <- t.test(df.V.SDT_ww$self_moral,df.V.SDT_ww$self_immoral,paired = TRUE)
df.V.SDT_ww$mrl_imm_slf <- df.V.SDT_ww$self_moral - df.V.SDT_ww$self_immoral
d.t.mrl_imm_slf.CI <- bootES(df.V.SDT_ww$mrl_imm_slf,R = 10000, effect.type = "cohens.d")

d.tvalue.mrl_imm_slf <- round(as.numeric(d.t.mrl_imm_slf[[1]]),3)
df.mrl_imm_slf <- as.numeric(d.t.mrl_imm_slf[[2]])
pvalue.mrl_imm_slf.adj <- p.adjust(as.numeric(d.t.mrl_imm_slf[[3]],"bonferroni",3))
cohens.d.mrl_imm_slf <- round(d.t.mrl_imm_slf.CI[[1]],4) 
d.CI.L.mrl_imm_slf <- round(d.t.mrl_imm_slf.CI[[12]][1],4)
d.CI.H.mrl_imm_slf <- round(d.t.mrl_imm_slf.CI[[12]][2],4)

# moral self vs ordinary self
d.t.mrl_ord_slf <- t.test(df.V.SDT_ww$self_moral,df.V.SDT_ww$self_ordinary,paired = TRUE)
df.V.SDT_ww$mrl_ord_slf <- df.V.SDT_ww$self_moral - df.V.SDT_ww$self_ordinary
d.t.mrl_ord_slf.CI <- bootES(df.V.SDT_ww$mrl_ord_slf,R = 10000, effect.type = "cohens.d")

d.tvalue.mrl_ord_slf  <- round(as.numeric(d.t.mrl_ord_slf[[1]]),3)
df.mrl_ord_slf  <- as.numeric(d.t.mrl_ord_slf[[2]])
pvalue.mrl_ord_slf.adj <- p.adjust(as.numeric(d.t.mrl_ord_slf[[3]],"bonferroni",3))
cohens.d.mrl_ord_slf <- round(d.t.mrl_ord_slf.CI[[1]],4) 
d.CI.L.mrl_ord_slf <- round(d.t.mrl_ord_slf.CI[[12]][1],4)
d.CI.H.mrl_ord_slf <- round(d.t.mrl_ord_slf.CI[[12]][2],4)

# immoral self vs. ordinary self
d.t.imm_ord_slf <- t.test(df.V.SDT_ww$self_immoral,df.V.SDT_ww$self_ordinary,paired = TRUE)
df.V.SDT_ww$imm_ord_slf <- df.V.SDT_ww$self_immoral - df.V.SDT_ww$self_ordinary
d.t.imm_ord_slf.CI <- bootES(df.V.SDT_ww$imm_ord_slf,R = 10000, effect.type = "cohens.d")

d.tvalue.imm_ord_slf  <- round(as.numeric(d.t.imm_ord_slf[[1]]),3)
df.imm_ord_slf  <- as.numeric(d.t.imm_ord_slf[[2]])
pvalue.imm_ord_slf.adj <- p.adjust(as.numeric(d.t.imm_ord_slf[[3]],"bonferroni",3))
cohens.d.imm_ord_slf <- round(d.t.imm_ord_slf.CI[[1]],4) 
d.CI.L.imm_ord_slf <- round(d.t.imm_ord_slf.CI[[12]][1],4)
d.CI.H.imm_ord_slf <- round(d.t.imm_ord_slf.CI[[12]][2],4)

# moral other vs. immoral other
d.t.mrl_imm_oth <- t.test(df.V.SDT_ww$other_moral,df.V.SDT_ww$other_immoral,paired = TRUE)
df.V.SDT_ww$mrl_imm_oth <- df.V.SDT_ww$other_moral - df.V.SDT_ww$other_immoral
d.t.mrl_imm_oth.CI <- bootES(df.V.SDT_ww$mrl_imm_oth,R = 10000, effect.type = "cohens.d")

d.tvalue.mrl_imm_oth  <- round(as.numeric(d.t.mrl_imm_oth[[1]]),3)
df.mrl_imm_oth  <- as.numeric(d.t.mrl_imm_oth[[2]])
pvalue.mrl_imm_oth.adj <- p.adjust(as.numeric(d.t.mrl_imm_oth[[3]],"bonferroni",3))
cohens.d.mrl_imm_oth <- round(d.t.mrl_imm_oth.CI[[1]],4) 
d.CI.L.mrl_imm_oth <- round(d.t.mrl_imm_oth.CI[[12]][1],4)
d.CI.H.mrl_imm_oth <- round(d.t.mrl_imm_oth.CI[[12]][2],4)

# moral other vs. ordinalry other
d.t.mrl_ord_oth <- t.test(df.V.SDT_ww$other_moral,df.V.SDT_ww$other_ordinary,paired = TRUE)
df.V.SDT_ww$mrl_ord_oth <- df.V.SDT_ww$other_moral - df.V.SDT_ww$other_ordinary
d.t.mrl_ord_oth.CI <- bootES(df.V.SDT_ww$mrl_ord_oth,R = 10000, effect.type = "cohens.d")

d.tvalue.mrl_ord_oth  <- round(as.numeric(d.t.mrl_ord_oth[[1]]),3)
df.mrl_ord_oth  <- as.numeric(d.t.mrl_ord_oth[[2]])
pvalue.mrl_ord_oth.adj <- p.adjust(as.numeric(d.t.mrl_ord_oth[[3]],"bonferroni",3))
cohens.d.mrl_ord_oth <- round(d.t.mrl_ord_oth.CI[[1]],4) 
d.CI.L.mrl_ord_oth <- round(d.t.mrl_ord_oth.CI[[12]][1],4)
d.CI.H.mrl_ord_oth <- round(d.t.mrl_ord_oth.CI[[12]][2],4)

# immoral other vs. ordinary other
d.t.imm_ord_oth <- t.test(df.V.SDT_ww$other_immoral,df.V.SDT_ww$other_ordinary,paired = TRUE)
df.V.SDT_ww$imm_ord_oth <- df.V.SDT_ww$other_immoral - df.V.SDT_ww$other_ordinary
d.t.imm_ord_oth.CI <- bootES(df.V.SDT_ww$imm_ord_oth,R = 10000, effect.type = "cohens.d")

d.tvalue.imm_ord_oth  <- round(as.numeric(d.t.imm_ord_oth[[1]]),3)
df.imm_ord_oth  <- as.numeric(d.t.imm_ord_oth[[2]])
d.pvalue.imm_ord_oth.adj <- p.adjust(as.numeric(d.t.imm_ord_oth[[3]],"bonferroni",3))
cohens.d.imm_ord_oth <- round(d.t.imm_ord_oth.CI[[1]],4) 
d.CI.L.imm_ord_oth <- round(d.t.imm_ord_oth.CI[[12]][1],4)
d.CI.H.imm_ord_oth <- round(d.t.imm_ord_oth.CI[[12]][2],4)

# moral self vs moral other
d.t.slf_oth_mrl <- t.test(df.V.SDT_ww$self_moral,df.V.SDT_ww$other_moral,paired = TRUE)
df.V.SDT_ww$slf_oth_mrl <- df.V.SDT_ww$self_moral - df.V.SDT_ww$other_moral
d.t.slf_oth_mrl.CI <- bootES(df.V.SDT_ww$slf_oth_mrl,R = 10000, effect.type = "cohens.d")

d.tvalue.slf_oth_mrl  <- round(as.numeric(d.t.slf_oth_mrl[[1]]),3)
df.slf_oth_mrl  <- as.numeric(d.t.slf_oth_mrl[[2]])
d.pvalue.slf_oth_mrl.adj <- p.adjust(as.numeric(d.t.slf_oth_mrl[[3]],"bonferroni",3))
cohens.d.slf_oth_mrl <- round(d.t.slf_oth_mrl.CI[[1]],4) 
d.CI.L.slf_oth_mrl <- round(d.t.slf_oth_mrl.CI[[12]][1],4)
d.CI.H.slf_oth_mrl <- round(d.t.slf_oth_mrl.CI[[12]][2],4)

# ordinary self vs. ordinary other
d.t.slf_oth_ord <- t.test(df.V.SDT_ww$self_ordinary,df.V.SDT_ww$other_ordinary,paired = TRUE)
df.V.SDT_ww$slf_oth_ord <- df.V.SDT_ww$self_ordinary - df.V.SDT_ww$other_ordinary
d.t.slf_oth_ord.CI <- bootES(df.V.SDT_ww$slf_oth_ord,R = 10000, effect.type = "cohens.d")

d.tvalue.slf_oth_ord  <- round(as.numeric(d.t.slf_oth_ord[[1]]),3)
df.slf_oth_ord  <- as.numeric(d.t.slf_oth_ord[[2]])
d.pvalue.slf_oth_ord.adj <- p.adjust(as.numeric(d.t.slf_oth_ord[[3]],"bonferroni",3))
cohens.d.slf_oth_ord <- round(d.t.slf_oth_ord.CI[[1]],4) 
d.CI.L.slf_oth_ord <- round(d.t.slf_oth_ord.CI[[12]][1],4)
d.CI.H.slf_oth_ord <- round(d.t.slf_oth_ord.CI[[12]][2],4)

# immoral self vs. immoral other
d.t.slf_oth_imm <- t.test(df.V.SDT_ww$self_immoral,df.V.SDT_ww$other_immoral,paired = TRUE)
df.V.SDT_ww$slf_oth_imm <- df.V.SDT_ww$self_immoral - df.V.SDT_ww$other_immoral
d.t.slf_oth_imm.CI <- bootES(df.V.SDT_ww$slf_oth_imm,R = 10000, effect.type = "cohens.d")

d.tvalue.slf_oth_imm  <- round(as.numeric(d.t.slf_oth_imm[[1]]),3)
df.slf_oth_imm <- as.numeric(d.t.slf_oth_imm[[2]])
d.pvalue.slf_oth_imm.adj <- p.adjust(as.numeric(d.t.slf_oth_imm[[3]],"bonferroni",3))
cohens.d.slf_oth_imm <- round(d.t.slf_oth_imm.CI[[1]],4) 
d.CI.L.slf_oth_imm <- round(d.t.slf_oth_imm.CI[[12]][1],4)
d.CI.H.slf_oth_imm <- round(d.t.slf_oth_imm.CI[[12]][2],4)

## plot and save the results of d'
df.V.SDT.sum <- summarySEwithin(df.V.SDT_w,measurevar = 'dprime',withinvars = c('morality','Identity'), idvar = 'Subject')

p_dprime <- ggplot(data = df.V.SDT.sum,aes(y = dprime, x = Identity, group = morality,shape = morality, fill = morality)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3) +         # Thinner lines
        geom_errorbar(aes(ymin = dprime - se, ymax = dprime + se),
        #geom_errorbar(aes(ymin = 1, ymax = 4),
                      size = .3,
                      width = .2,
                      position=position_dodge(.9)) +
        labs(x = 'self-referential',y = 'd prime') +
        #ylab(" Reaction times") + 
        #ylim(1, 4) +
        ggtitle("d prime for each condition") +
        coord_cartesian(ylim=c(1,3.5))+
        scale_y_continuous(breaks = seq(1,3.5,0.5),expand = c(0, 0)) +
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter. 
        #theme_classic()
        apatheme

# ggsave('dprime_mean_plot.png', width=4, height=6, unit='in', dpi=300)  # save the plot
```

The effect of `r d_anova1[[1]][1,1]`: *F*(`r d_anova1[[1]][1,2]`, `r d_anova1[[1]][1,3]`) = `r round(d_anova1[[1]][1,4],3)`, *p* = `r round(d_anova1[[1]][1,5],4)`, $\eta_g^2$ = `r round(d_anova1[[1]][1,7],4)`

The effect of `r d_anova1[[1]][2,1]`: *F*(`r d_anova1[[1]][2,2]`, `r d_anova1[[1]][2,3]`) = `r round(d_anova1[[1]][2,4],3)`, *p* = `r round(d_anova1[[1]][2,5],4)`, $\eta_g^2$ = `r round(d_anova1[[1]][2,7],4)`

The effect of `r d_anova1[[1]][3,1]`: *F*(`r d_anova1[[1]][3,2]`, `r d_anova1[[1]][3,3]`) = `r round(d_anova1[[1]][3,4],3)`, *p* = `r round(d_anova1[[1]][3,5],4)`, $\eta_g^2$ = `r round(d_anova1[[1]][3,7],4)`.

Then we conducted sample effect analysis for self- and other- association separately for the matched trials (see figure 1).

Moral self vs immoral self: *t*(`r df.mrl_imm_slf`) = `r d.tvalue.mrl_imm_slf`, *p* = 
`r pvalue.mrl_imm_slf.adj`, *Cohen's* $d_z$ = `r cohens.d.mrl_imm_slf`, 95% CI [`r d.CI.L.mrl_imm_slf` `r d.CI.H.mrl_imm_slf`]

Moral self vs. ordinary self: *t*(`r df.mrl_ord_slf`) = `r d.tvalue.mrl_ord_slf`, *p* = 
`r pvalue.mrl_ord_slf.adj`, *Cohen's* $d_z$ = `r cohens.d.mrl_ord_slf`, 95% CI [`r d.CI.L.mrl_ord_slf` `r d.CI.H.mrl_ord_slf`]

Immoral self vs. ordinary self: *t*(`r df.imm_ord_slf`) = `r d.tvalue.imm_ord_slf`, *p* = 
`r pvalue.imm_ord_slf.adj`, *Cohen's* $d_z$ = `r cohens.d.imm_ord_slf`, 95% CI [`r d.CI.L.imm_ord_slf` `r d.CI.H.imm_ord_slf`]

Moral other vs immoral other: *t*(`r df.mrl_imm_oth`) = `r d.tvalue.mrl_imm_oth`, *p* = 
`r pvalue.mrl_imm_oth.adj`, *Cohen's* $d_z$ = `r cohens.d.mrl_imm_oth`, 95% CI [`r d.CI.L.mrl_imm_oth` `r d.CI.H.mrl_imm_oth`]

Moral other vs. ordinary other: *t*(`r df.mrl_ord_oth`) = `r d.tvalue.mrl_ord_oth`, *p* = 
`r pvalue.mrl_ord_oth.adj`, *Cohen's* $d_z$ = `r cohens.d.mrl_ord_oth`, 95% CI [`r d.CI.L.mrl_ord_oth` `r d.CI.H.mrl_ord_oth`]

Immoral other vs. ordinary other: *t*(`r df.imm_ord_oth`) = `r d.tvalue.imm_ord_oth`, *p* = 
`r d.pvalue.imm_ord_oth.adj`, *Cohen's* $d_z$ = `r cohens.d.imm_ord_oth`, 95% CI [`r d.CI.L.imm_ord_oth` `r d.CI.H.imm_ord_oth`]

To examine the effect of self-relatedness, we also conducted t-test for self-other pair for each moral condition. 
moral self vs. moral other: *t*(`r df.slf_oth_mrl`) = `r d.tvalue.slf_oth_mrl`, *p* = `r d.pvalue.slf_oth_mrl.adj`, *Cohen's* $d_z$ = `r cohens.d.slf_oth_mrl`, 95% CI [`r d.CI.L.slf_oth_mrl` `r d.CI.H.slf_oth_mrl`]
ordinary self vs. ordinary other: *t*(`r df.slf_oth_ord`) = `r d.tvalue.slf_oth_ord`, *p* = `r d.pvalue.slf_oth_ord.adj`, *Cohen's* $d_z$ = `r cohens.d.slf_oth_ord`, 95% CI [`r d.CI.L.slf_oth_ord` `r d.CI.H.slf_oth_ord`]
immoral self vs. immoral other: *t*(`r df.slf_oth_imm`) = `r d.tvalue.slf_oth_imm`, *p* = `r d.pvalue.slf_oth_imm.adj`, *Cohen's* $d_z$ = `r cohens.d.slf_oth_imm`, 95% CI [`r d.CI.L.slf_oth_imm` `r d.CI.H.slf_oth_imm`]


```{r plot the d prime, fig.width=4, fig.height=6,echo=FALSE,warning=FALSE,message=FALSE }
ggplot(data = df.V.SDT.sum,aes(y = dprime, x = Identity, group = morality,shape = morality, fill = morality)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3) +         # Thinner lines
        geom_errorbar(aes(ymin = dprime - se, ymax = dprime + se),
        #geom_errorbar(aes(ymin = 1, ymax = 4),
                      size = .3,
                      width = .2,
                      position=position_dodge(.9)) +
        labs(x = 'self-referential',y = 'd prime') +
        #ylab(" Reaction times") + 
        #ylim(1, 4) +
        ggtitle("d prime for each condition") +
        coord_cartesian(ylim=c(1,3.5))+
        scale_y_continuous(breaks = seq(1,3.5,0.5),expand = c(0, 0)) +
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter. 
        #theme_classic()
        apatheme

# ggsave('dprime_mean_plot.png', width=4, height=6, unit='in', dpi=300)  # save the plot
```

```{r analyzing RT,echo=FALSE,results='hide',warning=FALSE, message=FALSE}
## plot density of each subject's RT and save them individually
subNo <- unique(df.V$Subject)
## doing the analysis for RT ####
df.V.RT <- df.V[df.V$ACC ==1,]  # exclued rt data less than 200 ms, and inaccurate data
df.V.RT.subj <- summarySE(df.V.RT,measurevar = 'RT', groupvar = c('Subject','matchness','morality','Identity'), na.rm = TRUE)
df.V.RT.grand <- summarySEwithin(df.V.RT.subj,measurevar = 'RT', withinvar = c('matchness','morality','Identity'),idvar = 'Subject',na.rm = TRUE)
df.V.RT_match <- df.V.RT[df.V.RT$matchness == "match",]
df.V.RT_nonmatch <- df.V.RT[df.V.RT$matchness == "nonmatch",]

rt_anova.match <- ezANOVA(df.V.RT_match,dv = RT, wid = Subject, within=.(morality,Identity),within_full=.(Identity,morality), type=3)
rt_anova.nonmatch <- ezANOVA(df.V.RT_nonmatch,dv = RT, wid = Subject, within=.(morality,Identity),within_full=.(Identity,morality), type=3)

## t-test 
df.V.RT.subj_w <- dcast(df.V.RT.subj, Subject ~ matchness + Identity + morality ,value.var = "RT") 

rt.t.m.mrl_imm_slf <- t.test(df.V.RT.subj_w$match_self_moral,df.V.RT.subj_w$match_self_immoral,paired = TRUE)
df.V.RT.subj_w$m.mrl_imm_slf <- df.V.RT.subj_w$match_self_moral - df.V.RT.subj_w$match_self_immoral
rt.t.m.mrl_imm_slf.CI <- bootES(df.V.RT.subj_w$m.mrl_imm_slf, R = 5000,effect.type = "cohens.d")

rt.tvalue.mrl_imm_slf  <- round(as.numeric(rt.t.m.mrl_imm_slf [[1]]),3)
rt.df.mrl_imm_slf  <- as.numeric(rt.t.m.mrl_imm_slf [[2]])
rt.pvalue.mrl_imm_slf.adj <- p.adjust(as.numeric(rt.t.m.mrl_imm_slf [[3]],"bonferroni",3))
rt.cohens.mrl_imm_slf <- round(rt.t.m.mrl_imm_slf.CI[[1]],4) 
rt.CI.L.mrl_imm_slf <- round(rt.t.m.mrl_imm_slf.CI[[12]][1],4)
rt.CI.H.mrl_imm_slf <- round(rt.t.m.mrl_imm_slf.CI[[12]][2],4)


rt.t.m.mrl_ord_slf <- t.test(df.V.RT.subj_w$match_self_moral,df.V.RT.subj_w$match_self_ordinary,paired = TRUE)
df.V.RT.subj_w$m.mrl_ord_slf <- df.V.RT.subj_w$match_self_moral - df.V.RT.subj_w$match_self_ordinary
rt.t.m.mrl_ord_slf.CI <- bootES(df.V.RT.subj_w$m.mrl_ord_slf, R = 5000,effect.type = "cohens.d")

rt.tvalue.mrl_ord_slf  <- round(as.numeric(rt.t.m.mrl_ord_slf [[1]]),3)
rt.df.mrl_ord_slf  <- as.numeric(rt.t.m.mrl_ord_slf[[2]])
rt.pvalue.mrl_ord_slf.adj <- p.adjust(as.numeric(rt.t.m.mrl_ord_slf[[3]],"bonferroni",3))
rt.cohens.mrl_ord_slf <- round(rt.t.m.mrl_ord_slf.CI[[1]],4) 
rt.CI.L.mrl_ord_slf <- round(rt.t.m.mrl_ord_slf.CI[[12]][1],4)
rt.CI.H.mrl_ord_slf <- round(rt.t.m.mrl_ord_slf.CI[[12]][2],4)


rt.t.m.imm_ord_slf <- t.test(df.V.RT.subj_w$match_self_immoral,df.V.RT.subj_w$match_self_ordinary,paired = TRUE)
df.V.RT.subj_w$m.imm_ord_slf <- df.V.RT.subj_w$match_self_immoral - df.V.RT.subj_w$match_self_ordinary
rt.t.m.imm_ord_slf.CI <- bootES(df.V.RT.subj_w$m.imm_ord_slf, R = 5000,effect.type = "cohens.d")

rt.tvalue.imm_ord_slf  <- round(as.numeric(rt.t.m.imm_ord_slf[[1]]),3)
rt.df.imm_ord_slf  <- as.numeric(rt.t.m.imm_ord_slf[[2]])
rt.pvalue.imm_ord_slf.adj <- p.adjust(as.numeric(rt.t.m.imm_ord_slf[[3]],"bonferroni",3))
rt.cohens.imm_ord_slf <- round(rt.t.m.imm_ord_slf.CI [[1]],4) 
rt.CI.L.imm_ord_slf <- round(rt.t.m.imm_ord_slf.CI[[12]][1],4)
rt.CI.H.imm_ord_slf <- round(rt.t.m.imm_ord_slf.CI[[12]][2],4)

rt.t.m.mrl_imm_oth <- t.test(df.V.RT.subj_w$match_self_moral,df.V.RT.subj_w$match_self_immoral,paired = TRUE)
df.V.RT.subj_w$m.mrl_imm_oth <- df.V.RT.subj_w$match_self_moral - df.V.RT.subj_w$match_self_immoral
rt.t.m.mrl_imm_oth.CI <- bootES(df.V.RT.subj_w$m.mrl_imm_oth, R = 5000,effect.type = "cohens.d")

rt.tvalue.mrl_imm_oth  <- round(as.numeric(rt.t.m.mrl_imm_oth [[1]]),3)
rt.df.mrl_imm_oth  <- as.numeric(rt.t.m.mrl_imm_oth [[2]])
rt.pvalue.mrl_imm_oth.adj <- p.adjust(as.numeric(rt.t.m.mrl_imm_oth [[3]],"bonferroni",3))
rt.cohens.mrl_imm_oth <- round(rt.t.m.mrl_imm_oth.CI [[1]],4) 
rt.CI.L.mrl_imm_oth <- round(rt.t.m.mrl_imm_oth.CI [[12]][1],4)
rt.CI.H.mrl_imm_oth <- round(rt.t.m.mrl_imm_oth.CI [[12]][2],4)


rt.t.m.mrl_ord_oth <- t.test(df.V.RT.subj_w$match_self_moral,df.V.RT.subj_w$match_self_ordinary,paired = TRUE)
df.V.RT.subj_w$m.mrl_ord_oth <- df.V.RT.subj_w$match_self_moral - df.V.RT.subj_w$match_self_ordinary
rt.t.m.mrl_ord_oth.CI <- bootES(df.V.RT.subj_w$m.mrl_ord_oth, R = 5000,effect.type = "cohens.d")

rt.tvalue.mrl_ord_oth  <- round(as.numeric(rt.t.m.mrl_ord_oth [[1]]),3)
rt.df.mrl_ord_oth  <- as.numeric(rt.t.m.mrl_ord_oth[[2]])
rt.pvalue.mrl_ord_oth.adj <- p.adjust(as.numeric(rt.t.m.mrl_ord_oth[[3]],"bonferroni",3))
rt.cohens.mrl_ord_oth <- round(rt.t.m.mrl_ord_oth.CI [[1]],4) 
rt.CI.L.mrl_ord_oth <- round(rt.t.m.mrl_ord_oth.CI [[12]][1],4)
rt.CI.H.mrl_ord_oth <- round(rt.t.m.mrl_ord_oth.CI [[12]][2],4)


rt.t.m.imm_ord_oth <- t.test(df.V.RT.subj_w$match_self_immoral,df.V.RT.subj_w$match_self_ordinary,paired = TRUE)
df.V.RT.subj_w$m.imm_ord_oth <- df.V.RT.subj_w$match_self_immoral - df.V.RT.subj_w$match_self_ordinary
rt.t.m.imm_ord_oth.CI <- bootES(df.V.RT.subj_w$m.imm_ord_oth, R = 5000,effect.type = "cohens.d")

rt.tvalue.imm_ord_oth  <- round(as.numeric(rt.t.m.imm_ord_oth[[1]]),3)
rt.df.imm_ord_oth  <- as.numeric(rt.t.m.imm_ord_oth[[2]])
rt.pvalue.imm_ord_oth.adj <- p.adjust(as.numeric(rt.t.m.imm_ord_oth[[3]],"bonferroni",3))
rt.cohens.imm_ord_oth <- round(rt.t.m.imm_ord_oth.CI[[1]],4) 
rt.CI.L.imm_ord_oth <- round(rt.t.m.imm_ord_oth.CI[[12]][1],4)
rt.CI.H.imm_ord_oth <- round(rt.t.m.imm_ord_oth.CI[[12]][2],4)


rt.t.m.slf_oth_mrl <- t.test(df.V.RT.subj_w$match_self_moral,df.V.RT.subj_w$match_other_moral,paired = TRUE)
df.V.RT.subj_w$m.slf_oth_mrl <- df.V.RT.subj_w$match_self_moral - df.V.RT.subj_w$match_other_moral
rt.t.m.slf_oth_mrl.CI <- bootES(df.V.RT.subj_w$m.slf_oth_mrl, R = 5000,effect.type = "cohens.d")

rt.tvalue.slf_oth_mrl  <- round(as.numeric(rt.t.m.slf_oth_mrl[[1]]),3)
rt.df.slf_oth_mrl  <- as.numeric(rt.t.m.slf_oth_mrl[[2]])
rt.pvalue.slf_oth_mrl.adj <- p.adjust(as.numeric(rt.t.m.slf_oth_mrl[[3]],"bonferroni",3))
rt.cohens.slf_oth_mrl <- round(rt.t.m.slf_oth_mrl.CI[[1]],4) 
rt.CI.L.slf_oth_mrl <- round(rt.t.m.slf_oth_mrl.CI[[12]][1],4)
rt.CI.H.slf_oth_mrl <- round(rt.t.m.slf_oth_mrl.CI[[12]][2],4)

rt.t.m.slf_oth_imm <- t.test(df.V.RT.subj_w$match_self_immoral,df.V.RT.subj_w$match_other_immoral,paired = TRUE)
df.V.RT.subj_w$m.slf_oth_imm <- df.V.RT.subj_w$match_self_immoral - df.V.RT.subj_w$match_other_immoral
rt.t.m.slf_oth_imm.CI <- bootES(df.V.RT.subj_w$m.slf_oth_imm, R = 5000,effect.type = "cohens.d")

rt.tvalue.slf_oth_imm  <- round(as.numeric(rt.t.m.slf_oth_imm[[1]]),3)
rt.df.slf_oth_imm  <- as.numeric(rt.t.m.slf_oth_imm[[2]])
rt.pvalue.slf_oth_imm.adj <- p.adjust(as.numeric(rt.t.m.slf_oth_imm[[3]],"bonferroni",3))
rt.cohens.slf_oth_imm <- round(rt.t.m.slf_oth_imm.CI[[1]],4) 
rt.CI.L.slf_oth_imm <- round(rt.t.m.slf_oth_imm.CI[[12]][1],4)
rt.CI.H.slf_oth_imm <- round(rt.t.m.slf_oth_imm.CI[[12]][2],4)


rt.t.m.slf_oth_ord <- t.test(df.V.RT.subj_w$match_self_ordinary,df.V.RT.subj_w$match_other_ordinary,paired = TRUE)
df.V.RT.subj_w$m.slf_oth_ord <- df.V.RT.subj_w$match_self_ordinary - df.V.RT.subj_w$match_other_ordinary
rt.t.m.slf_oth_ord.CI <- bootES(df.V.RT.subj_w$m.slf_oth_ord, R = 5000,effect.type = "cohens.d")

rt.tvalue.slf_oth_ord  <- round(as.numeric(rt.t.m.slf_oth_ord[[1]]),3)
rt.df.slf_oth_ord  <- as.numeric(rt.t.m.slf_oth_ord[[2]])
rt.pvalue.slf_oth_ord.adj <- p.adjust(as.numeric(rt.t.m.slf_oth_ord[[3]],"bonferroni",3))
rt.cohens.slf_oth_ord <- round(rt.t.m.slf_oth_ord.CI[[1]],4) 
rt.CI.L.slf_oth_ord <- round(rt.t.m.slf_oth_ord.CI[[12]][1],4)
rt.CI.H.slf_oth_ord <- round(rt.t.m.slf_oth_ord.CI[[12]][2],4)

df.V.RT.grand.match <- df.V.RT.grand[df.V.RT.grand$matchness == "match",]
p_rt <- ggplot(data = df.V.RT.grand.match, aes(x=morality,y=RT,group=Identity,shape = Identity,fill = Identity)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3) +         # Thinner lines
        geom_errorbar(aes(ymin = RT-se, ymax = RT + se),
                      size = .3,
                      width = .2,
                      position=position_dodge(.9)) +
        xlab("Moral valence") +
        ylab(" Reaction times (ms)") + 
        coord_cartesian(ylim=c(500,800))+
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter.
        #ylim(0.3, 0.8) +
        ggtitle("RT for each condition") +
        scale_y_continuous("Reation Times  (ms)",expand = c(0, 0)) + 
        apatheme
ggsave('RT_mean_plot.png', width=4, height=6, unit='in', dpi=300)  # save the plot

```

We conducted a 3 * 2 rmANOVA for RT
For the matched trials, 
The effect of `r rt_anova.match[[1]][1,1]`: *F*(`r rt_anova.match[[1]][1,2]`, `r rt_anova.match[[1]][1,3]`) = `r round(rt_anova.match[[1]][1,4],3)`, *p* = `r round(rt_anova.match[[1]][1,5],4)`, $\eta_g^2$ = `r round(rt_anova.match[[1]][1,7],4)`

The effect of `r rt_anova.match[[1]][2,1]`: *F*(`r rt_anova.match[[1]][2,2]`, `r rt_anova.match[[1]][2,3]`) = `r round(rt_anova.match[[1]][2,4],3)`, *p* = `r round(rt_anova.match[[1]][2,5],4)`, $\eta_g^2$ = `r round(rt_anova.match[[1]][2,7],4)`

The effect of `r rt_anova.match[[1]][3,1]`: *F*(`r rt_anova.match[[1]][3,2]`, `r rt_anova.match[[1]][3,3]`) = `r round(rt_anova.match[[1]][3,4],3)`, *p* = `r round(rt_anova.match[[1]][3,5],4)`, $\eta_g^2$ = `r round(rt_anova.match[[1]][3,7],4)`.

For the nonmatched trials, 
The effect of `r rt_anova.nonmatch[[1]][1,1]`: *F*(`r rt_anova.nonmatch[[1]][1,2]`, `r rt_anova.nonmatch[[1]][1,3]`) = `r round(rt_anova.nonmatch[[1]][1,4],3)`, *p* = `r round(rt_anova.nonmatch[[1]][1,5],4)`, $\eta_g^2$ = `r round(rt_anova.nonmatch[[1]][1,7],4)`

The effect of `r rt_anova.nonmatch[[1]][2,1]`: *F*(`r rt_anova.nonmatch[[1]][2,2]`, `r rt_anova.nonmatch[[1]][2,3]`) = `r round(rt_anova.nonmatch[[1]][2,4],3)`, *p* = `r round(rt_anova.nonmatch[[1]][2,5],4)`, $\eta_g^2$ = `r round(rt_anova.nonmatch[[1]][2,7],4)`

The effect of `r rt_anova.nonmatch[[1]][3,1]`: *F*(`r rt_anova.nonmatch[[1]][3,2]`, `r rt_anova.nonmatch[[1]][3,3]`) = `r round(rt_anova.nonmatch[[1]][3,4],3)`, *p* = `r round(rt_anova.nonmatch[[1]][3,5],4)`, $\eta_g^2$ = `r round(rt_anova.nonmatch[[1]][3,7],4)`.

Then we conducted sample effect analysis for self- and other- association separately for the matched trials.

Moral self vs immoral self: *t*(`r rt.df.mrl_imm_slf`) = `r rt.tvalue.mrl_imm_slf`, *p* = 
`r rt.pvalue.mrl_imm_slf.adj`, *Cohen's* $d_z$ = `r rt.cohens.mrl_imm_slf`, 95% CI [`r rt.CI.L.mrl_imm_slf` `r rt.CI.H.mrl_imm_slf`]

Moral self vs. ordinary self: *t*(`r rt.df.mrl_ord_slf`) = `r rt.tvalue.mrl_ord_slf`, *p* = 
`r rt.pvalue.mrl_ord_slf.adj`, *Cohen's* $d_z$ = `r rt.cohens.mrl_ord_slf`, 95% CI [`r rt.CI.L.mrl_ord_slf` `r rt.CI.H.mrl_ord_slf`]

Immoral self vs. ordinary self: *t*(`r rt.df.imm_ord_slf`) = `r rt.tvalue.imm_ord_slf`, *p* = 
`r rt.pvalue.imm_ord_slf.adj`, *Cohen's* $d_z$ = `r rt.cohens.imm_ord_slf`, 95% CI [`r rt.CI.L.imm_ord_slf` `r rt.CI.H.imm_ord_slf`]

Moral other vs immoral other: *t*(`r rt.df.mrl_imm_oth`) = `r rt.tvalue.mrl_imm_oth`, *p* = 
`r rt.pvalue.mrl_imm_oth.adj`, *Cohen's* $d_z$ = `r rt.cohens.mrl_imm_oth`, 95% CI [`r rt.CI.L.mrl_imm_oth` `r rt.CI.H.mrl_imm_oth`]

Moral other vs. ordinary other: *t*(`r rt.df.mrl_ord_oth`) = `r rt.tvalue.mrl_ord_oth`, *p* = 
`r rt.pvalue.mrl_ord_oth.adj`, *Cohen's* $d_z$ = `r rt.cohens.mrl_ord_oth`, 95% CI [`r rt.CI.L.mrl_ord_oth` `r rt.CI.H.mrl_ord_oth`]

Immoral other vs. ordinary other: *t*(`r rt.df.imm_ord_oth`) = `r rt.tvalue.imm_ord_oth`, *p* = 
`r rt.pvalue.imm_ord_oth.adj`, *Cohen's* $d_z$ = `r rt.cohens.imm_ord_oth`, 95% CI [`r rt.CI.L.imm_ord_oth` `r rt.CI.H.imm_ord_oth`]

To examine the effect of self-relatedness, we also conducted t-test for self-other pair for each moral condition.

moral self vs. moral other: *t*(`r rt.df.slf_oth_mrl`) = `r rt.tvalue.slf_oth_mrl`, *p* = `r rt.pvalue.slf_oth_mrl.adj`, *Cohen's* $d_z$ = `r rt.cohens.slf_oth_mrl`, 95% CI [`r rt.CI.L.slf_oth_mrl` `r rt.CI.H.slf_oth_mrl`]

ordinary self vs. ordinary other: *t*(`r rt.df.slf_oth_ord`) = `r rt.tvalue.slf_oth_ord`, *p* = `r rt.pvalue.slf_oth_ord.adj`, *Cohen's* $d_z$ = `r rt.cohens.slf_oth_ord`, 95% CI [`r rt.CI.L.slf_oth_ord` `r rt.CI.H.slf_oth_ord`]

immoral self vs. immoral other: *t*(`r rt.df.slf_oth_imm`) = `r rt.tvalue.slf_oth_imm`, *p* = `r rt.pvalue.slf_oth_imm.adj`, *Cohen's* $d_z$ = `r rt.cohens.slf_oth_imm`, 95% CI [`r rt.CI.L.slf_oth_imm` `r rt.CI.H.slf_oth_imm`]



```{r plot the RT1, fig.width=4, fig.height=6,echo=FALSE,warning=FALSE,message=FALSE }
# df.V.RT.grand.match <- df.V.RT.grand[df.V.RT.grand$matchness == "match",]
ggplot(data = df.V.RT.grand.match, aes(x=morality,y=RT,group=Identity,shape = Identity,fill = Identity)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3) +         # Thinner lines
        geom_errorbar(aes(ymin = RT-se, ymax = RT + se),
                      size = .3,
                      width = .2,
                      position=position_dodge(.9)) +
        xlab("Moral valence") +
        ylab(" Reaction times (ms)") + 
        coord_cartesian(ylim=c(500,800))+
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter.
        #ylim(0.3, 0.8) +
        ggtitle("RT for each condition") +
        scale_y_continuous("Reation Times  (ms)",expand = c(0, 0)) + 
        apatheme
#ggsave('RT_mean_plot.png', width=4, height=6, unit='in', dpi=300)  # save the plot

```

The above is the reaction time for each condition


```{r plot the RT2, fig.width=4, fig.height=6,echo=FALSE,warning=FALSE,message=FALSE }
# change a way to plot
ggplot(data = df.V.RT.grand.match, aes(x=Identity,y=RT,group=morality,shape = morality,fill = morality)) +
        geom_bar(position = position_dodge(),stat = "identity",colour = "black", size=.3) +         # Thinner lines
        geom_errorbar(aes(ymin = RT-se, ymax = RT + se),
                      size = .3,
                      width = .2,
                      position=position_dodge(.9)) +
        xlab("Moral valence") +
        ylab(" Reaction times (ms)") + 
        coord_cartesian(ylim=c(500,800)) +
        scale_y_continuous(breaks=seq(500,800,50),expand = c(0, 0)) +
        scale_fill_grey (start=0.2, end=0.8) +   # using grey scale, start from darker, end to lighter.
        #ylim(0.3, 0.8) +
        ggtitle("RT for each condition") +
        #scale_y_continuous("Reation Times (ms)") + 
        apatheme
ggsave('RT_mean_plot2.png', width=4, height=6, unit='in', dpi=300)  # save the plot

```
The above is another way to plot.
